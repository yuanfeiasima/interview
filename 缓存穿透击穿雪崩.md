# 缓存穿透、击穿、雪崩

## 核心要点（面试快速回答）

**Q: 三个问题的区别是什么？**
穿透：查询不存在的数据，缓存和DB都没有，每次都打DB。击穿：热点key过期，瞬间大量请求打DB。雪崩：大量key同时过期，DB压力骤增。

**Q: 如何解决缓存穿透？**
两个方案：1）布隆过滤器，在查缓存前先判断key是否存在；2）缓存空值，查不到也缓存null，TTL设短一点（5分钟）。我们两种都用，布隆过滤器拦截99%，剩下1%缓存空值。

**Q: 如何解决缓存击穿？**
热点key永不过期+主动更新。识别热点key（QPS>1000），设置永不过期，通过后台任务定时刷新。极端情况用分布式锁，只让一个请求查DB。

**Q: 如何解决缓存雪崩？**
三个手段：1）过期时间加随机值（避免同时过期）；2）热点数据永不过期；3）Redis集群+多级缓存（本地缓存兜底）。实际效果：Redis故障时，本地缓存命中率从30%提升到60%。

---

## 一、缓存穿透

### 1.1 问题描述

**什么是缓存穿透？**
查询一个不存在的数据，缓存中没有，DB中也没有，每次请求都会打到DB。

**典型场景：**
- 恶意攻击：故意查询不存在的商品ID
- 业务bug：前端传错参数
- 爬虫：随机生成ID爬取数据

**危害：**
- DB压力大，可能被打挂
- 缓存失去意义
- 影响正常业务


### 1.2 解决方案

**方案1：布隆过滤器**

**原理：**
- 将所有存在的商品ID加载到布隆过滤器
- 查询前先判断ID是否存在
- 不存在直接返回，不查DB

**实现：**
```java
@Component
public class BloomFilterService {
    private BloomFilter<Long> productBloomFilter;
    
    @PostConstruct
    public void init() {
        // 初始化布隆过滤器，预计50亿数据，误判率0.01%
        productBloomFilter = BloomFilter.create(
            Funnels.longFunnel(),
            5_000_000_000L,
            0.0001
        );
        
        // 加载所有商品ID
        loadAllProductIds();
    }
    
    public boolean mightExist(Long productId) {
        return productBloomFilter.mightContain(productId);
    }
}
```


**优点：**
- 内存占用小（50亿数据只需6GB）
- 查询速度快（O(1)）
- 拦截率高（99%+）

**缺点：**
- 有误判率（0.01%）
- 不支持删除
- 需要定期重建


**方案2：缓存空值**

**原理：**
- 查询不到数据时，缓存一个null值
- 下次查询直接返回null，不查DB
- 设置较短的TTL（5分钟）

**实现：**
```java
public Product getProduct(Long productId) {
    // 先查缓存
    String cacheKey = "product:" + productId;
    String value = redis.get(cacheKey);
    
    if (value != null) {
        if ("NULL".equals(value)) {
            return null;  // 缓存的空值
        }
        return JSON.parseObject(value, Product.class);
    }
    
    // 查DB
    Product product = dbDao.query(productId);
    
    if (product == null) {
        // 缓存空值，TTL=5分钟
        redis.setex(cacheKey, 300, "NULL");
    } else {
        redis.setex(cacheKey, 3600, JSON.toJSONString(product));
    }
    
    return product;
}
```


**优点：**
- 实现简单
- 完全避免DB查询

**缺点：**
- 占用缓存空间
- 可能被恶意攻击（大量不存在的ID）

**我们的方案：布隆过滤器 + 缓存空值**
- 布隆过滤器拦截99%
- 剩下1%（误判）用缓存空值兜底

---


## 二、缓存击穿

### 2.1 问题描述

**什么是缓存击穿？**
热点key过期的瞬间，大量并发请求同时打到DB。

**典型场景：**
- 爆款商品缓存过期
- 热门餐厅信息过期
- 秒杀商品缓存失效

**危害：**
- DB瞬间压力激增
- 可能导致DB连接耗尽
- 影响其他业务


### 2.2 解决方案

**方案1：热点key永不过期**

**原理：**
- 识别热点key（QPS>1000）
- 设置永不过期
- 后台任务定时刷新

**实现思路：**
- 监控key的访问频率
- 热点key标记为永不过期
- 定时任务每5分钟刷新一次


**方案2：分布式锁**

**原理：**
- 缓存失效时，用分布式锁控制
- 只让一个请求查DB
- 其他请求等待或返回旧数据

**实现：**
```java
public Product getProduct(Long productId) {
    String cacheKey = "product:" + productId;
    Product product = redis.get(cacheKey);
    
    if (product == null) {
        String lockKey = "lock:" + productId;
        if (redis.setnx(lockKey, "1", 10)) {  // 获取锁
            try {
                // 查DB
                product = dbDao.query(productId);
                redis.set(cacheKey, product, 3600);
            } finally {
                redis.del(lockKey);  // 释放锁
            }
        } else {
            // 等待100ms后重试
            Thread.sleep(100);
            return getProduct(productId);
        }
    }
    
    return product;
}
```


**我们的方案：热点key永不过期 + 主动刷新**
- 更优雅，不需要锁
- 性能更好
- 适合高并发场景

---

## 三、缓存雪崩

### 3.1 问题描述

**什么是缓存雪崩？**
大量key同时过期，瞬间所有请求都打到DB。

**典型场景：**
- 批量导入数据，设置相同过期时间
- Redis集群故障，所有缓存失效
- 重启后缓存全部失效

**危害：**
- DB压力骤增，可能崩溃
- 系统整体不可用
- 恢复时间长


### 3.2 解决方案

**方案1：过期时间加随机值**

**原理：**
- 避免大量key同时过期
- 在基础TTL上加随机值

**实现：**
```java
// 基础TTL 1小时，加上0-300秒随机值
int ttl = 3600 + ThreadLocalRandom.current().nextInt(300);
redis.setex(key, ttl, value);
```


**方案2：热点数据永不过期**
- 核心数据设置永不过期
- 后台任务定时刷新
- 保证关键业务不受影响

**方案3：多级缓存**
- 本地缓存 + Redis
- Redis故障时，本地缓存兜底
- 实际效果：Redis故障时，本地缓存命中率从30%提升到60%


**方案4：Redis集群高可用**
- 主从复制 + 哨兵
- 或Redis Cluster
- 故障自动切换

---

## 四、线上事故案例

### 4.1 事故1：布隆过滤器未更新

**问题：**
- 新上架商品，布隆过滤器未及时更新
- 用户查询新商品，被布隆过滤器拦截
- 大量用户投诉看不到新商品

**原因：**
- 布隆过滤器每天凌晨重建一次
- 白天新增商品未加入


**解决方案：**
- 改为实时更新布隆过滤器
- 新增商品时，同步更新布隆过滤器
- 增加降级逻辑：布隆过滤器判断不存在时，仍然查一次缓存


### 4.2 事故2：Redis集群故障

**问题：**
- Redis集群主节点故障
- 切换到从节点耗时30秒
- 30秒内所有请求打到DB
- DB连接数瞬间打满，部分请求超时

**解决方案：**
- 本地缓存兜底
- 限流保护DB
- 优化Redis集群切换时间（降到5秒）

---


## 五、实施效果

**穿透防护：**
- 布隆过滤器拦截率：99%+
- 恶意请求拦截：100万次/天
- DB压力降低：95%

**击穿防护：**
- 热点key识别：实时监控
- 永不过期key数量：约10万个
- DB瞬时压力：降低90%

**雪崩防护：**
- Redis故障时本地缓存命中率：60%
- 系统可用性：从99.9%提升到99.95%
- 故障恢复时间：从5分钟降到30秒
