# 热点数据处理

## 核心要点（面试快速回答）

**Q: 如何识别热点数据？**
两种方式：1）离线分析：每天统计Top 10万商品，作为基础热点；2）实时识别：用滑动窗口统计，1分钟内访问量>1000的判定为实时热点。两者结合，既有基础热点预热，又能应对突发热点。

**Q: 热点数据的缓存策略和普通数据有什么不同？**
三个差异：1）缓存层级：热点数据优先放本地缓存，普通数据主要在Redis；2）过期策略：热点数据TTL更长（5分钟），普通数据30秒；3）容灾策略：热点数据有多级兜底，普通数据可以接受降级。

**Q: 有没有做本地缓存的动态预热？**
有。实时热点识别后，会通过MQ广播到所有机器，触发本地缓存预热。同时监控访问趋势，对"即将成为热点"的数据提前预热。大促前还会根据历史数据预测热点，提前加载。

**Q: 遇到过热点问题导致的故障吗？**
遇到过。某网红直播带货，单品QPS飙到5万，打爆了Redis单个分片。后来引入热点探测+本地缓存兜底，热点流量在应用层消化，不打到Redis。

---

## 一、热点数据的特征

### 1.1 什么是热点数据？

**定义：** 在短时间内被大量访问的数据

**外卖场景的热点来源：**
```
1. 头部商家的热门商品
   - 某奶茶店的招牌奶茶
   - 某快餐店的套餐

2. 营销活动商品
   - 限时秒杀商品
   - 满减活动商品

3. 突发事件
   - 网红直播带货
   - 社交媒体爆款

4. 季节性热点
   - 夏天的冷饮
   - 冬天的火锅
```

### 1.2 热点数据的分布规律

```
访问量分布（典型的帕累托分布，也就是二八原则）：
- Top 1%商品：占35%访问量
- Top 10%商品：占70%访问量
- Top 30%商品：占90%访问量
- 其余70%商品：占10%访问量

热点商品特征：
- 单品QPS可达1万+
- 持续时间：分钟到小时级别
- 突发性强，难以预测
```

### 1.3 热点带来的问题

| 问题 | 描述 | 后果 |
|-----|-----|-----|
| 缓存热点 | 大量请求打到同一个Redis节点 | Redis节点过载 |
| DB热点 | 缓存miss后大量请求打到同一个DB分片 | DB被打挂 |
| 本地缓存失效 | 热点数据在本地缓存过期 | 瞬间大量请求穿透 |
| 网络热点 | 热点数据响应大，带宽打满 | 网络拥塞 |

---

## 二、热点识别机制

### 2.1 离线热点分析

**实现方式：**
```
每天凌晨分析前一天的访问日志：
1. 统计每个商品的访问量
2. 按访问量排序，取Top 10万
3. 生成热点商品列表
4. 推送到配置中心
```

**数据结构：**
```java
public class HotProductConfig {
    // 热点商品ID列表（Top 10万）
    private Set<Long> hotProductIds;

    // 热点等级划分
    private Map<Long, Integer> productHotLevel;
    // Level 1: Top 1000，极热
    // Level 2: Top 10000，很热
    // Level 3: Top 100000，热

    // 更新时间
    private LocalDateTime updateTime;
}
```

**使用场景：**
- 应用启动时预热这些商品到本地缓存
- 为热点商品配置更高的缓存优先级
- 监控热点商品的访问趋势

### 2.2 实时热点探测

**实时探测的必要性**：离线分析只能发现"历史热点"，无法应对突发热点（如网红直播带货）。实时探测通过滑动窗口统计每个商品的访问量，一旦超过阈值就标记为热点，触发本地缓存预热。

**滑动窗口的设计**：
- 窗口大小1分钟，分成6个bucket，每个10秒
- 只统计最近1分钟的访问量，过期的自动丢弃
- 阈值1000次/分钟是经验值，可以根据业务调整

```java
public class RealtimeHotspotDetector {

    // 滑动窗口：1分钟，分成6个bucket，每个10秒
    private Map<Long, SlidingWindow> productWindows = new ConcurrentHashMap<>();

    // 热点阈值：1分钟内访问量 > 1000
    private static final int HOTSPOT_THRESHOLD = 1000;

    public void recordAccess(Long productId) {
        SlidingWindow window = productWindows.computeIfAbsent(
            productId, k -> new SlidingWindow(6, 10_000));
        window.increment();
    }

    public boolean isHotspot(Long productId) {
        SlidingWindow window = productWindows.get(productId);
        if (window == null) {
            return false;
        }
        return window.getCount() > HOTSPOT_THRESHOLD;
    }

    // 获取当前所有热点
    public Set<Long> getAllHotspots() {
        return productWindows.entrySet().stream()
            .filter(e -> e.getValue().getCount() > HOTSPOT_THRESHOLD)
            .map(Map.Entry::getKey)
            .collect(Collectors.toSet());
    }
}
```

**滑动窗口实现：**

**实现要点**：
- 使用AtomicLong数组作为bucket，保证线程安全
- 通过时间戳计算当前bucket索引，实现窗口滑动
- 定期清理过期bucket，避免统计到过期数据
- 这是一种空间换时间的设计，用固定大小的数组实现O(1)的统计

```java
public class SlidingWindow {
    private AtomicLong[] buckets;
    private int bucketCount;
    private long bucketDurationMs;
    private AtomicLong lastUpdateTime;

    public void increment() {
        long now = System.currentTimeMillis();
        int bucketIndex = (int) ((now / bucketDurationMs) % bucketCount);

        // 检查是否需要清理过期bucket
        cleanExpiredBuckets(now);

        buckets[bucketIndex].incrementAndGet();
        lastUpdateTime.set(now);
    }

    public long getCount() {
        cleanExpiredBuckets(System.currentTimeMillis());
        long total = 0;
        for (AtomicLong bucket : buckets) {
            total += bucket.get();
        }
        return total;
    }
}
```

### 2.3 热点预测

**预测的价值**：如果等商品已经成为热点再处理，可能已经来不及（瞬间流量已经打爆Redis）。通过分析访问量增长趋势，可以预测"即将成为热点"的商品，提前预热。

**预测算法**：观察最近3分钟的访问量增长率，如果连续2分钟增长率都超过50%，说明有爆发趋势，标记为"即将成为热点"。

```java
public class HotspotPredictor {

    // 访问量增长率阈值：每分钟增长50%以上
    private static final double GROWTH_RATE_THRESHOLD = 0.5;

    public boolean willBecomeHotspot(Long productId) {
        // 获取最近3分钟的访问量
        long[] recentCounts = getRecentMinuteCounts(productId, 3);

        // 计算增长率
        if (recentCounts[0] == 0) {
            return false;
        }
        double growthRate1 = (double) recentCounts[1] / recentCounts[0] - 1;
        double growthRate2 = (double) recentCounts[2] / recentCounts[1] - 1;

        // 连续两分钟增长率都超过阈值，预测为即将成为热点
        return growthRate1 > GROWTH_RATE_THRESHOLD
            && growthRate2 > GROWTH_RATE_THRESHOLD;
    }
}
```

**应用场景：**
- 提前预热即将成为热点的商品
- 提前扩容相关资源
- 发送预警通知

---

## 三、热点缓存策略

### 3.1 多级缓存的差异化配置

```java
public class HotspotCacheConfig {

    // 热点商品缓存配置
    public CacheConfig getHotspotConfig() {
        return CacheConfig.builder()
            .localCacheTTL(Duration.ofMinutes(5))    // 本地缓存5分钟
            .redisCacheTTL(Duration.ofMinutes(30))   // Redis 30分钟
            .localCacheMaxSize(100_000)              // 本地最多缓存10万热点
            .refreshAhead(true)                       // 提前刷新
            .refreshAheadTime(Duration.ofSeconds(30)) // 过期前30秒刷新
            .build();
    }

    // 普通商品缓存配置
    public CacheConfig getNormalConfig() {
        return CacheConfig.builder()
            .localCacheTTL(Duration.ofSeconds(30))   // 本地缓存30秒
            .redisCacheTTL(Duration.ofMinutes(5))    // Redis 5分钟
            .localCacheMaxSize(1_000_000)            // 本地最多缓存100万
            .refreshAhead(false)                      // 不提前刷新
            .build();
    }
}
```

### 3.2 热点数据的本地缓存优化

**提前刷新机制**：传统缓存是"过期后再加载"，会有一个缓存miss的窗口。对于热点数据，我们在过期前30秒就异步刷新，保证缓存始终有效。这样热点请求永远不会穿透到下层，实现"零miss"。

**异步刷新的关键**：刷新是异步的，不阻塞当前请求。当前请求继续返回旧值（虽然快过期但还有效），同时后台加载新值。

```java
public class RefreshAheadCache<K, V> {

    private Cache<K, CacheEntry<V>> cache;
    private Duration ttl;
    private Duration refreshAheadTime;
    private Function<K, V> loader;
    private ExecutorService refreshExecutor;

    public V get(K key) {
        CacheEntry<V> entry = cache.getIfPresent(key);

        if (entry == null) {
            // 缓存miss，同步加载
            return loadAndCache(key);
        }

        // 检查是否需要提前刷新
        if (entry.shouldRefresh(refreshAheadTime)) {
            // 异步刷新，不阻塞当前请求
            refreshExecutor.submit(() -> loadAndCache(key));
        }

        return entry.getValue();
    }

    private V loadAndCache(K key) {
        V value = loader.apply(key);
        cache.put(key, new CacheEntry<>(value, System.currentTimeMillis()));
        return value;
    }

    @Data
    private static class CacheEntry<V> {
        private V value;
        private long createTime;

        public boolean shouldRefresh(Duration refreshAheadTime) {
            long age = System.currentTimeMillis() - createTime;
            return age > (ttl.toMillis() - refreshAheadTime.toMillis());
        }
    }
}
```

### 3.3 热点数据的Redis优化

**热点分片问题**：按商品ID哈希分片时，热点商品会集中在某个分片，导致这个分片过载而其他分片空闲。两个解决方案：

**方案1：本地缓存消化**（推荐）
热点商品优先走本地缓存，不打Redis。本地缓存是每台机器独立的，天然分散了压力。

**方案2：热点多副本**
热点商品在Redis存多个副本（主key+3个副本），读取时随机选择一个副本，把压力分散到不同分片。缺点是存储翻倍、更新要写多份。

```java
// 热点商品优先查本地缓存
public ProductDTO getProduct(Long productId) {
    // 热点商品优先查本地缓存
    if (hotspotDetector.isHotspot(productId)) {
        ProductDTO cached = localCache.get(productId);
        if (cached != null) {
            return cached;  // 本地缓存命中，不打Redis
        }
    }

    // 非热点或本地缓存miss，查Redis
    return getFromRedis(productId);
}
```

**解决方案2：热点数据多副本**
```java
// 热点数据在Redis存多个副本
public void cacheHotProduct(Long productId, ProductDTO product) {
    // 主key
    redisTemplate.opsForValue().set("product:" + productId, product);

    // 如果是热点，额外存3个副本
    if (hotspotDetector.isHotspot(productId)) {
        for (int i = 0; i < 3; i++) {
            String replicaKey = "product:" + productId + ":replica:" + i;
            redisTemplate.opsForValue().set(replicaKey, product);
        }
    }
}

// 读取时随机选择一个副本
public ProductDTO getHotProduct(Long productId) {
    if (hotspotDetector.isHotspot(productId)) {
        int replica = ThreadLocalRandom.current().nextInt(4);  // 0-3
        String key = replica == 0
            ? "product:" + productId
            : "product:" + productId + ":replica:" + (replica - 1);
        return redisTemplate.opsForValue().get(key);
    }
    return redisTemplate.opsForValue().get("product:" + productId);
}
```

---

## 四、动态预热机制

### 4.1 启动预热

```java
@Component
public class StartupCacheWarmer {

    @PostConstruct
    public void warmUp() {
        log.info("Starting cache warm-up...");

        // 1. 加载离线热点列表
        Set<Long> hotProductIds = hotspotConfigService.getHotProductIds();
        log.info("Loaded {} hot products from config", hotProductIds.size());

        // 2. 分批预热
        List<List<Long>> batches = Lists.partition(
            new ArrayList<>(hotProductIds), 1000);

        for (List<Long> batch : batches) {
            warmUpBatch(batch);
        }

        log.info("Cache warm-up completed");
    }

    private void warmUpBatch(List<Long> productIds) {
        // 批量从Redis加载
        List<ProductDTO> products = productService.batchGetFromRedis(productIds);

        // 写入本地缓存
        for (ProductDTO product : products) {
            localCache.put(product.getId(), product);
        }
    }
}
```

### 4.2 实时热点预热广播

**广播机制的必要性**：单机探测到热点后，只有这台机器的本地缓存有数据。其他机器还是要查Redis。通过MQ广播，可以让所有机器同时预热，实现集群级别的热点保护。

**使用广播模式**：MQ消费模式设为BROADCASTING，确保每台机器都能收到消息。普通的集群消费模式只有一台机器能收到，不适合预热场景。

**热点发现后广播到所有机器：**
```java
@Component
public class HotspotBroadcaster {

    @Autowired
    private RocketMQTemplate mqTemplate;

    // 发现新热点时广播
    public void broadcastNewHotspot(Long productId) {
        HotspotMessage message = new HotspotMessage();
        message.setProductId(productId);
        message.setAction("WARM_UP");
        message.setTimestamp(System.currentTimeMillis());

        // 广播到所有消费者
        mqTemplate.send("hotspot_broadcast_topic", message);
    }
}

@Component
@RocketMQMessageListener(
    topic = "hotspot_broadcast_topic",
    consumerGroup = "product_service_group",
    messageModel = MessageModel.BROADCASTING)  // 广播模式
public class HotspotBroadcastListener {

    @Autowired
    private LocalCache localCache;

    @Autowired
    private ProductService productService;

    public void onMessage(HotspotMessage message) {
        if ("WARM_UP".equals(message.getAction())) {
            // 预热到本地缓存
            ProductDTO product = productService.getFromRedis(message.getProductId());
            if (product != null) {
                localCache.put(message.getProductId(), product);
                log.info("Warmed up hotspot product: {}", message.getProductId());
            }
        }
    }
}
```

### 4.3 大促预热

**大促前根据历史数据预热：**
```java
@Component
public class PromotionCacheWarmer {

    // 大促前1小时执行
    @Scheduled(cron = "0 0 10 * * ?")  // 假设大促11点开始
    public void warmUpForPromotion() {
        // 1. 获取参与大促的商品
        List<Long> promotionProductIds = promotionService.getPromotionProductIds();

        // 2. 获取历史大促的热点商品
        List<Long> historyHotProducts = analyticsService.getHistoryPromotionHotProducts();

        // 3. 合并去重
        Set<Long> toWarmUp = new HashSet<>();
        toWarmUp.addAll(promotionProductIds);
        toWarmUp.addAll(historyHotProducts);

        // 4. 预热到Redis和本地缓存
        warmUpProducts(toWarmUp);

        // 5. 标记为高优先级，防止被淘汰
        markAsHighPriority(toWarmUp);

        log.info("Promotion warm-up completed, {} products", toWarmUp.size());
    }
}
```

---

## 五、热点防护措施

### 5.1 热点限流

**为什么热点要单独限流**：全局限流可能误伤正常请求。比如整体限流1万QPS，一个热点商品占了9000，其他商品只能分1000。单独对热点限流（比如单品5000 QPS），可以保护系统的同时，让其他商品正常访问。

**限流后的降级**：被限流的请求不是直接拒绝，而是走本地缓存降级。可能数据稍旧，但比拒绝服务好。

```java
@Component
public class HotspotRateLimiter {

    // 热点商品的限流配置
    // 单个热点商品最多5000 QPS
    private static final int HOTSPOT_RATE_LIMIT = 5000;

    private Map<Long, RateLimiter> rateLimiters = new ConcurrentHashMap<>();

    public boolean tryAcquire(Long productId) {
        if (!hotspotDetector.isHotspot(productId)) {
            return true;  // 非热点不限流
        }

        RateLimiter limiter = rateLimiters.computeIfAbsent(
            productId,
            k -> RateLimiter.create(HOTSPOT_RATE_LIMIT));

        return limiter.tryAcquire();
    }
}

// 在接口层使用
public ProductDTO getProduct(Long productId) {
    // 热点限流检查
    if (!hotspotRateLimiter.tryAcquire(productId)) {
        // 被限流，走降级逻辑
        return getProductFromLocalCache(productId);
    }

    return getProductNormal(productId);
}
```

### 5.2 热点隔离

**隔离的价值**：热点商品和普通商品共用资源时，热点可能把资源耗尽，影响普通商品。资源隔离通过独立的线程池，保证热点再怎么抢，也不会影响普通商品的资源配额。

**线程池设计**：
- 热点线程池：核心50，最大100，队列1000
- 普通线程池：核心100，最大200，队列5000
- 热点线程池小一些，因为热点请求量大但应该快速完成（有缓存）
- 普通线程池大一些，因为可能有缓存miss需要查DB

```java
@Configuration
public class ThreadPoolConfig {

    // 热点商品专用线程池
    @Bean("hotspotExecutor")
    public ExecutorService hotspotExecutor() {
        return new ThreadPoolExecutor(
            50, 100, 60, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(1000),
            new NamedThreadFactory("hotspot-"),
            new CallerRunsPolicy());
    }

    // 普通商品线程池
    @Bean("normalExecutor")
    public ExecutorService normalExecutor() {
        return new ThreadPoolExecutor(
            100, 200, 60, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(5000),
            new NamedThreadFactory("normal-"),
            new CallerRunsPolicy());
    }
}

// 使用不同的线程池处理
public CompletableFuture<ProductDTO> getProductAsync(Long productId) {
    ExecutorService executor = hotspotDetector.isHotspot(productId)
        ? hotspotExecutor
        : normalExecutor;

    return CompletableFuture.supplyAsync(
        () -> getProduct(productId), executor);
}
```

### 5.3 热点熔断

```java
// 热点商品单独的熔断配置
@HystrixCommand(
    commandKey = "getHotProduct",
    threadPoolKey = "hotspotPool",
    fallbackMethod = "getHotProductFallback",
    commandProperties = {
        @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold",
                         value = "100"),   // 热点请求量大，阈值也要高
        @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage",
                         value = "30"),    // 错误率阈值更低，更敏感
        @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",
                         value = "100")    // 超时时间更短
    },
    threadPoolProperties = {
        @HystrixProperty(name = "coreSize", value = "50"),
        @HystrixProperty(name = "maxQueueSize", value = "100")
    }
)
public ProductDTO getHotProduct(Long productId) {
    return productService.getById(productId);
}

public ProductDTO getHotProductFallback(Long productId) {
    // 热点商品的降级数据
    return localCache.get(productId);
}
```

---

## 六、实战案例

### 6.1 案例1：网红直播带货

**事故背景：**
- 某网红在直播间推荐了一款奶茶
- 瞬间该商品QPS从100飙升到5万
- 打爆了Redis分片，影响了该分片上的其他商品

**处理过程：**
```
20:00 - 直播开始推荐商品
20:01 - 商品QPS从100飙升到2万
20:02 - 实时热点探测识别到异常
20:02 - 自动触发本地缓存预热
20:03 - QPS继续飙升到5万
20:03 - Redis分片CPU达到90%，开始出现超时
20:04 - 热点限流生效，单品限流5000 QPS
20:04 - 超出限流的请求走本地缓存降级
20:05 - Redis分片压力下降，恢复正常
```

**复盘改进：**
1. 热点探测阈值从1000降低到500，更早发现
2. 热点商品自动在Redis存多副本
3. 与运营建立沟通机制，大型直播提前报备

### 6.2 案例2：大促热点预热

**场景：双11大促**

**预热策略：**
```
大促前1周：
- 分析去年同期热点商品
- 分析本次促销活动商品
- 生成预热名单（约50万商品）

大促前1天：
- 预热到Redis（全量）
- 验证缓存命中率

大促前1小时：
- 预热到本地缓存（Top 10万）
- 提高本地缓存TTL到10分钟
- 开启热点商品多副本

大促期间：
- 实时热点探测 + 动态预热
- 热点限流保护
- 监控大盘实时关注
```

**效果：**
- 热点商品本地缓存命中率达到60%
- Redis热点分片压力降低80%
- 大促期间无热点相关故障

---

## 七、监控与告警

### 7.1 热点监控大盘

```
┌──────────────────────────────────────────────────┐
│              热点商品监控大盘                      │
├──────────────────────────────────────────────────┤
│ 当前热点商品数：158                               │
│ 热点商品总QPS：12.5万                             │
│ 热点流量占比：35%                                 │
│                                                  │
│ Top 10 热点商品：                                 │
│ ┌────────┬─────────┬───────┬────────┐           │
│ │ 商品ID │ 商品名   │  QPS  │ 热度等级│           │
│ ├────────┼─────────┼───────┼────────┤           │
│ │ 12345  │ 招牌奶茶 │ 8500  │ 极热   │           │
│ │ 12346  │ 炸鸡套餐 │ 6200  │ 极热   │           │
│ │ ...    │ ...     │ ...   │ ...    │           │
│ └────────┴─────────┴───────┴────────┘           │
│                                                  │
│ 本地缓存命中率：32%                               │
│ 热点商品本地缓存命中率：58%                        │
│                                                  │
│ Redis热点分片负载：                               │
│ [████████████░░░░░░░░] 65%                       │
└──────────────────────────────────────────────────┘
```

### 7.2 告警规则

| 告警项 | 阈值 | 级别 |
|-------|-----|-----|
| 单品QPS突增 | >10倍日常 | P2 |
| 单品QPS超限 | >1万 | P1 |
| 热点分片CPU | >80% | P1 |
| 热点缓存命中率下降 | <40% | P2 |
| 新热点产生 | - | P3（通知） |

---

## 八、最佳实践总结

### 8.1 热点处理原则

1. **尽早识别**：越早发现热点，处理越从容
2. **本地消化**：热点流量尽量在应用层消化，不要打到Redis/DB
3. **多级兜底**：热点处理失败时要有降级方案
4. **资源隔离**：热点不能影响普通数据

### 8.2 经验总结

**什么情况下会出现热点问题？**
- 营销活动（秒杀、限时折扣）
- 网红效应（直播、种草）
- 突发事件（天气、节日）
- 系统故障恢复后的流量堆积

**热点问题的特点：**
- 突发性强，难以预测
- 持续时间不定（分钟到小时）
- 影响范围大（可能拖垮整个系统）

**应对策略：**
- 离线分析 + 实时探测相结合
- 预热 + 动态调整相结合
- 限流 + 降级相结合
