# 技术债务与重构

## 核心要点（面试快速回答）

**Q: 当前商品系统最大的技术债务是什么？**
三个主要债务：1）历史分层不清：早期代码业务逻辑和数据访问混在一起，改动风险高；2）接口设计不一致：不同时期的接口风格不统一，新人上手成本高；3）数据模型冗余：多次迭代后，有些字段已废弃但没清理，有些逻辑重复。最痛的是分层问题，改一个功能要改很多地方。

**Q: 如果让你重新设计，会做哪些不同的选择？**
三个关键改变：1）一开始就做好分层（领域驱动设计），不要图快混着写；2）分库分表的分片键要更谨慎选择，商家ID分片在跨商家查询时很痛苦；3）缓存策略要从一开始就设计好，后期改造成本很高。

**Q: 如何偿还技术债务？**
分三步：1）识别和评估：定期代码评审，识别债务，评估影响和修复成本；2）优先级排序：按"影响范围×修复难度"排序，优先修复高影响低难度的；3）持续偿还：每个迭代预留20%时间做重构，不要等积累太多再集中还。

**Q: 有没有成功的重构案例？**
有。我们做过商品详情接口的重构，原来是一个2000行的大方法，耦合了商品、库存、价格、活动等逻辑。重构后拆成独立模块，用组合模式聚合数据。RT从120ms降到50ms，代码行数减少40%，后续迭代效率提升明显。

---

## 一、技术债务识别

### 1.1 什么是技术债务？

```
技术债务的定义：
为了短期交付速度而采取的次优技术方案，
这些方案在未来会带来额外的维护成本。

技术债务的来源：
1. 时间压力：为了赶进度走捷径
2. 需求变化：原设计无法适应新需求
3. 知识不足：当时不知道更好的方案
4. 人员变动：交接不充分，理解不一致
5. 缺乏规范：没有统一的编码和设计标准
```

### 1.2 商品系统的主要技术债务

```
债务1：分层架构不清晰
├─ 问题：Service层直接写SQL，DAO层有业务逻辑
├─ 影响：改动一个功能要改多个地方，容易遗漏
├─ 修复成本：高（涉及大量代码重构）
└─ 紧急程度：中（能用，但维护痛苦）

债务2：接口设计不一致
├─ 问题：有的返回VO，有的返回Entity，命名风格不统一
├─ 影响：新人上手成本高，容易写出不一致的代码
├─ 修复成本：中（需要统一改造，但风险可控）
└─ 紧急程度：低（影响开发效率，不影响运行）

债务3：数据模型冗余
├─ 问题：废弃字段未清理，重复数据存在多处
├─ 影响：存储浪费，查询效率低，数据不一致风险
├─ 修复成本：中（需要数据迁移）
└─ 紧急程度：低（暂时不影响业务）

债务4：缺乏单元测试
├─ 问题：核心逻辑测试覆盖率不足30%
├─ 影响：改动没信心，回归成本高
├─ 修复成本：高（补测试工作量大）
└─ 紧急程度：中（影响迭代质量）

债务5：配置硬编码
├─ 问题：部分配置写在代码里，改配置要发版
├─ 影响：灵活性差，紧急调整困难
├─ 修复成本：低（逐步迁移到配置中心）
└─ 紧急程度：中（影响运维效率）
```

### 1.3 债务评估模型

**评估公式的含义**：综合得分 = (影响范围 × 紧急程度) / 修复难度。这个公式的逻辑是：影响大、紧急的债务要优先处理，但也要考虑修复难度。一个影响很大但修复也很难的债务，可能不如几个影响中等但容易修复的债务优先级高。

**优先级排序**：得分高的优先处理。这种量化方式让技术债务管理更客观，避免"谁嗓门大就先修谁的"的情况。

```java
// 技术债务评估
public class TechDebtAssessment {

    public DebtScore assess(TechDebt debt) {
        // 影响范围（1-5）
        int impactScope = assessImpactScope(debt);

        // 修复难度（1-5，越高越难）
        int fixDifficulty = assessFixDifficulty(debt);

        // 紧急程度（1-5）
        int urgency = assessUrgency(debt);

        // 综合得分 = 影响范围 × 紧急程度 / 修复难度
        double score = (impactScope * urgency) / (double) fixDifficulty;

        return new DebtScore(debt, score, impactScope, fixDifficulty, urgency);
    }
}

// 债务优先级排序
List<TechDebt> debts = getAllDebts();
debts.sort((a, b) -> Double.compare(
    assess(b).getScore(),
    assess(a).getScore()));
```

---

## 二、重构策略

### 2.1 重构原则

```
重构的核心原则：

1. 小步快跑
   - 每次只改一小部分
   - 频繁提交和验证
   - 避免大规模重写

2. 测试先行
   - 先补充测试覆盖
   - 确保重构不破坏功能
   - 测试是重构的安全网

3. 保持可用
   - 重构过程中系统始终可用
   - 通过开关控制新老逻辑
   - 可随时回滚

4. 业务优先
   - 重构不能影响业务迭代
   - 与业务需求结合进行
   - 价值导向，不为重构而重构
```

### 2.2 重构方法

```
常用重构手法：

1. 提取方法（Extract Method）
   - 把大方法拆成小方法
   - 每个方法只做一件事
   - 提高可读性和可测试性

2. 提取类（Extract Class）
   - 把大类拆成小类
   - 按职责划分
   - 降低耦合度

3. 移动方法（Move Method）
   - 把方法移到更合适的类
   - 让逻辑归属更清晰
   - 解决"特性依恋"问题

4. 引入参数对象（Introduce Parameter Object）
   - 把多个参数封装成对象
   - 减少参数数量
   - 便于扩展

5. 策略模式替换条件分支（Replace Conditional with Strategy）
   - 把if-else替换成策略
   - 便于扩展新分支
   - 遵循开闭原则
```

---

## 三、重构案例

### 3.1 案例1：商品详情接口重构

**问题分析**：2000行的大方法是典型的"上帝方法"，所有逻辑混在一起。问题包括：难以理解（要看完2000行才知道做什么）、难以测试（无法单独测试某部分）、难以复用（其他地方需要类似逻辑只能复制）、性能差（所有查询串行执行）。

**重构思路**：用"组合模式"把大方法拆成多个"组装器"，每个组装器负责一个独立的数据聚合任务。组装器之间无依赖的可以并行执行，有依赖的串行执行。

**重构前的问题：**
```java
// 重构前：2000行的大方法
public ProductDetailVO getProductDetail(Long productId, Long userId) {
    ProductDetailVO vo = new ProductDetailVO();

    // 1. 查询商品基础信息（200行）
    Product product = productDao.selectById(productId);
    vo.setId(product.getId());
    vo.setName(product.getName());
    // ... 更多字段设置

    // 2. 查询规格配料（300行）
    List<SpecGroup> specGroups = specDao.selectByProductId(productId);
    for (SpecGroup group : specGroups) {
        // 复杂的规格处理逻辑
    }

    // 3. 查询库存（200行）
    Stock stock = stockDao.selectByProductId(productId);
    // 复杂的库存计算逻辑

    // 4. 查询价格和活动（400行）
    List<Activity> activities = activityDao.selectByProductId(productId);
    // 复杂的价格计算逻辑

    // 5. 查询评价（300行）
    List<Review> reviews = reviewDao.selectByProductId(productId);
    // 评价统计和筛选逻辑

    // 6. 查询推荐商品（200行）
    List<Product> recommends = recommendService.getRecommends(productId);

    // 7. 用户相关（200行）
    // 收藏状态、浏览记录等

    return vo;
}

// 问题：
// 1. 方法太长，难以理解和维护
// 2. 职责不清，所有逻辑混在一起
// 3. 无法复用，其他接口无法使用这些逻辑
// 4. 难以测试，无法单独测试某一部分
// 5. 性能差，所有查询串行执行
```

**重构后的设计：**

**设计亮点**：
1. **接口抽象**：定义ProductDetailAssembler接口，每个组装器实现这个接口
2. **自动发现**：通过@Component注解，Spring自动注入所有组装器
3. **并行执行**：通过canParallel()标记，无依赖的组装器并行执行
4. **顺序控制**：通过getOrder()控制有依赖关系的组装器执行顺序
5. **上下文传递**：通过Context对象在组装器间传递数据

```java
// 重构后：使用组合模式

// 1. 定义数据组装接口
public interface ProductDetailAssembler {
    void assemble(ProductDetailContext context);
    int getOrder();  // 执行顺序
}

// 2. 实现各个组装器
@Component
@Order(1)
public class BasicInfoAssembler implements ProductDetailAssembler {
    @Override
    public void assemble(ProductDetailContext context) {
        Product product = productService.getById(context.getProductId());
        context.getResult().setBasicInfo(buildBasicInfo(product));
    }
}

@Component
@Order(2)
public class SpecAssembler implements ProductDetailAssembler {
    @Override
    public void assemble(ProductDetailContext context) {
        List<SpecGroupVO> specs = specService.getSpecs(context.getProductId());
        context.getResult().setSpecs(specs);
    }
}

@Component
@Order(3)
public class PriceAssembler implements ProductDetailAssembler {
    @Override
    public void assemble(ProductDetailContext context) {
        PriceVO price = priceService.calculate(
            context.getProductId(), context.getUserId());
        context.getResult().setPrice(price);
    }
}

// 更多组装器...

// 3. 主服务编排
@Service
public class ProductDetailService {

    @Autowired
    private List<ProductDetailAssembler> assemblers;

    public ProductDetailVO getProductDetail(Long productId, Long userId) {
        // 创建上下文
        ProductDetailContext context = new ProductDetailContext();
        context.setProductId(productId);
        context.setUserId(userId);
        context.setResult(new ProductDetailVO());

        // 可以并行执行的组装器
        List<CompletableFuture<Void>> futures = assemblers.stream()
            .filter(a -> a.canParallel())
            .map(a -> CompletableFuture.runAsync(() -> a.assemble(context)))
            .collect(Collectors.toList());

        // 等待并行任务完成
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();

        // 串行执行的组装器（有依赖关系）
        assemblers.stream()
            .filter(a -> !a.canParallel())
            .sorted(Comparator.comparing(ProductDetailAssembler::getOrder))
            .forEach(a -> a.assemble(context));

        return context.getResult();
    }
}
```

**重构效果：**
```
重构效果对比：

指标          | 重构前  | 重构后  | 提升
-------------|--------|--------|-----
代码行数      | 2000   | 1200   | -40%
方法数        | 1      | 15     | 职责单一
测试覆盖率    | 10%    | 80%    | +70%
RT (P99)     | 120ms  | 50ms   | -58%（并行化）
迭代效率      | 低     | 高     | 改一个模块不影响其他
```

### 3.2 案例2：分层架构重构

**问题分析**：Service层直接写SQL是"职责混乱"的表现。Service层应该关注业务逻辑，数据访问应该交给DAO层。混在一起会导致：业务逻辑难以复用、数据访问难以优化、代码难以测试。

**重构目标**：清晰的四层架构
- Controller：处理HTTP请求，参数校验
- Application（应用层）：编排业务流程，事务管理
- Domain（领域层）：核心业务逻辑，业务规则
- Infrastructure（基础设施层）：数据访问，外部服务调用

**重构前的问题：**
```java
// 重构前：Service层直接写SQL，职责混乱
@Service
public class ProductService {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public Product getProduct(Long id) {
        // Service层直接写SQL
        String sql = "SELECT * FROM product WHERE id = ?";
        return jdbcTemplate.queryForObject(sql, new ProductRowMapper(), id);
    }

    public void updateProduct(Product product) {
        // 业务逻辑和数据访问混在一起
        if (product.getPrice().compareTo(BigDecimal.ZERO) <= 0) {
            throw new BusinessException("价格必须大于0");
        }

        String sql = "UPDATE product SET name=?, price=? WHERE id=?";
        jdbcTemplate.update(sql, product.getName(), product.getPrice(), product.getId());

        // 缓存刷新逻辑也在这里
        redisTemplate.delete("product:" + product.getId());
    }
}
```

**重构后的分层：**
```java
// 重构后：清晰的分层架构

// 1. Controller层：处理HTTP请求
@RestController
@RequestMapping("/api/product")
public class ProductController {

    @Autowired
    private ProductApplicationService productAppService;

    @PostMapping
    public Result<ProductVO> createProduct(@RequestBody ProductCreateCommand command) {
        return Result.success(productAppService.createProduct(command));
    }
}

// 2. Application层：编排业务流程
@Service
public class ProductApplicationService {

    @Autowired
    private ProductDomainService productDomainService;
    @Autowired
    private CacheService cacheService;

    @Transactional
    public ProductVO createProduct(ProductCreateCommand command) {
        // 转换为领域对象
        Product product = ProductFactory.create(command);

        // 调用领域服务
        productDomainService.create(product);

        // 刷新缓存
        cacheService.refresh(product.getId());

        // 返回VO
        return ProductConverter.toVO(product);
    }
}

// 3. Domain层：核心业务逻辑
@Service
public class ProductDomainService {

    @Autowired
    private ProductRepository productRepository;

    public void create(Product product) {
        // 业务规则校验
        product.validate();

        // 持久化
        productRepository.save(product);

        // 发布领域事件
        DomainEventPublisher.publish(new ProductCreatedEvent(product));
    }
}

// 4. Infrastructure层：数据访问
@Repository
public class ProductRepositoryImpl implements ProductRepository {

    @Autowired
    private ProductMapper productMapper;

    @Override
    public void save(Product product) {
        ProductPO po = ProductConverter.toPO(product);
        productMapper.insert(po);
    }

    @Override
    public Product findById(Long id) {
        ProductPO po = productMapper.selectById(id);
        return ProductConverter.toDomain(po);
    }
}
```

---

## 四、重构过程管理

### 4.1 重构计划

```
重构计划模板：

1. 债务识别（1周）
   - 代码审查，识别问题
   - 与团队讨论，达成共识
   - 输出债务清单

2. 方案设计（1周）
   - 设计重构方案
   - 评估风险和成本
   - 制定里程碑

3. 测试准备（2周）
   - 补充单元测试
   - 补充集成测试
   - 建立测试基线

4. 分阶段重构（4-8周）
   - 按模块逐步重构
   - 每个阶段可独立上线
   - 持续验证功能正确

5. 收尾验收（1周）
   - 全量回归测试
   - 性能测试
   - 文档更新
```

### 4.2 风险控制

**Feature Flag的价值**：重构最怕的是"改坏了"。通过Feature Flag可以控制新老逻辑的切换，先让1%流量走新逻辑，观察没问题再逐步扩大。发现问题可以秒级关闭，不需要回滚代码。这是"安全重构"的关键技巧。

```java
// 使用Feature Flag控制新老逻辑
@Service
public class ProductService {

    @Autowired
    private FeatureFlagService featureFlags;

    public ProductDetailVO getProductDetail(Long productId) {
        // 通过Feature Flag控制走新逻辑还是老逻辑
        if (featureFlags.isEnabled("new_product_detail", productId)) {
            return newProductDetailService.getDetail(productId);
        } else {
            return oldProductDetailService.getDetail(productId);
        }
    }
}

// 灰度开启新逻辑
// 先1%流量验证 -> 10% -> 50% -> 100%
// 发现问题随时关闭
```

### 4.3 重构度量

```
重构效果度量指标：

代码质量指标：
- 代码行数变化
- 圈复杂度变化
- 重复代码率变化
- 测试覆盖率变化

运行时指标：
- RT变化
- 错误率变化
- 资源消耗变化

研发效率指标：
- 单次迭代时长变化
- Bug数量变化
- 新人上手时间变化
```

---

## 五、如果重新设计

### 5.1 架构层面

```
重新设计会做的改变：

1. 领域驱动设计（DDD）
   - 从一开始就做好领域划分
   - 清晰的限界上下文
   - 避免后期拆分的痛苦

2. 分库分表策略
   - 更谨慎选择分片键
   - 考虑跨分片查询场景
   - 可能选择"商家ID+时间"复合分片

3. 缓存架构
   - 一开始就设计多级缓存
   - 一致性方案提前规划
   - 热点识别和处理机制

4. 接口设计
   - 统一的API规范
   - 版本管理策略
   - 向后兼容原则
```

### 5.2 技术选型

```
技术选型反思：

1. ORM框架
   - 当时：MyBatis手写SQL
   - 反思：简单场景可以用JPA，提高效率
   - 复杂查询再用MyBatis

2. 缓存方案
   - 当时：直接用Redis Template
   - 反思：应该封装缓存门面，便于切换实现
   - 本地缓存应该一开始就有

3. 消息队列
   - 当时：RocketMQ
   - 反思：选择没问题，但消息schema管理要更规范
   - 消息版本化很重要

4. 监控体系
   - 当时：后期才完善
   - 反思：从Day1就应该有完整监控
   - "没有监控=裸奔"
```

### 5.3 研发流程

```
流程改进：

1. 代码审查
   - 强制Code Review
   - 架构师参与关键Review
   - 建立Review Checklist

2. 测试要求
   - 核心逻辑必须有单测
   - 测试覆盖率门禁
   - 自动化测试流水线

3. 文档规范
   - 接口文档必须先行
   - 架构决策记录（ADR）
   - 技术债务看板

4. 技术债务管理
   - 每个迭代预留20%偿债时间
   - 债务可视化
   - 定期Review和清理
```

---

## 六、技术债务治理机制

### 6.1 债务看板

```
技术债务看板示例：

┌──────────────────────────────────────────────────────────┐
│                   技术债务看板                            │
├──────────────────────────────────────────────────────────┤
│ 待处理 (5)        │ 进行中 (2)      │ 已完成 (8)        │
├──────────────────────────────────────────────────────────┤
│ [P1] 分层重构     │ [P1] 接口统一   │ [P2] 配置外置 ✓  │
│ [P2] 测试补充     │ [P2] 缓存优化   │ [P2] 日志规范 ✓  │
│ [P2] 废弃字段清理 │                 │ [P3] 命名规范 ✓  │
│ [P3] 文档完善     │                 │ ...              │
│ [P3] 工具升级     │                 │                  │
└──────────────────────────────────────────────────────────┘

本季度目标：完成3个P1债务，5个P2债务
当前进度：P1完成1/3，P2完成4/5
```

### 6.2 定期Review

```
技术债务Review会议：

频率：每两周一次
参与者：技术负责人、核心开发

议程：
1. 债务看板更新（10分钟）
   - 新增债务
   - 完成债务
   - 状态更新

2. 债务分析（20分钟）
   - 讨论高优先级债务
   - 评估修复方案
   - 分配负责人

3. 偿债计划（15分钟）
   - 下两周偿债目标
   - 与业务迭代协调
   - 资源分配

4. 经验分享（15分钟）
   - 分享重构经验
   - 讨论最佳实践
   - 避坑指南
```

---

## 七、最佳实践

### 7.1 预防技术债务

```
预防原则：

1. 设计先行
   - 不要急于写代码
   - 先做设计评审
   - 考虑扩展性

2. 代码规范
   - 统一编码标准
   - 强制代码审查
   - 静态代码检查

3. 持续重构
   - 每次改代码顺手优化
   - 不要等积累太多
   - "童子军规则"

4. 知识传承
   - 文档化架构决策
   - 新人培训
   - 代码注释（why，不是what）
```

### 7.2 偿还技术债务

```
偿还策略：

1. 优先级管理
   - 高影响+低难度：立即修复
   - 高影响+高难度：规划时间
   - 低影响+低难度：顺手修复
   - 低影响+高难度：评估是否值得

2. 与业务结合
   - 改动相关代码时顺便重构
   - 不要为重构而重构
   - 让重构产生业务价值

3. 持续投入
   - 每个迭代预留时间
   - 不要一次性还完
   - 保持可持续节奏
```
