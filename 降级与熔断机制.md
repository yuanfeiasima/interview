# 降级与熔断机制

## 核心要点（面试快速回答）

**Q: 商品系统的降级策略是什么？**
分4级降级：Level1从Redis读（可能延迟30秒）、Level2从本地缓存读（可能延迟5分钟）、Level3返回简化数据（只有核心字段）、Level4返回默认值或友好提示。目标是尽量停在Level1-2，避免到Level3-4。

**Q: 哪些功能可以降级？哪些必须保证？**
可降级：商品评价、推荐商品、销量统计、图片高清版本。必须保证：商品基本信息（名称、价格、库存）、下单核心链路。原则是"宁可数据延迟，不能影响下单"。

**Q: 降级决策是人工还是自动？**
两者结合。自动降级：基于熔断器（错误率>50%或RT>200ms触发）。人工降级：大促前预降级、紧急情况一键降级。自动为主，人工兜底。

**Q: 熔断后如何恢复？**
采用半开状态探测：熔断后每10秒放一个请求试探，连续3次成功后进入半开状态（放10%流量），再连续成功后逐步恢复（30%→50%→100%）。整个恢复过程约2-5分钟。

---

## 一、降级体系设计

### 1.1 为什么需要降级？

**核心矛盾：**
- 系统100%可用是不可能的
- 但用户体验要尽可能保障
- 降级是在"完全不可用"和"完全可用"之间找平衡

**降级的目标：**
- 保障核心链路可用（能下单）
- 牺牲非核心功能换取稳定性
- 给用户返回"有价值的信息"，而不是冷冰冰的错误

### 1.2 功能重要性分级

```
P0（必须保障）：
- 商品基本信息（名称、价格、图片）
- 库存状态
- 商品状态（上架/下架）
- 下单核心链路

P1（重要，优先保障）：
- 商品详情描述
- 规格选项
- 配送信息

P2（次要，可降级）：
- 用户评价
- 销量数据
- 推荐商品
- 商品视频

P3（辅助，优先降级）：
- 高清大图（可降级为缩略图）
- 动态标签
- 实时热度
```

---

## 二、四级降级策略

### 2.1 降级等级定义

| 等级 | 数据来源 | 数据新鲜度 | 用户感知 | 触发条件 |
|-----|---------|-----------|---------|---------|
| Level 0 | 正常查询 | 实时 | 无感知 | 正常情况 |
| Level 1 | Redis缓存 | 延迟30秒 | 几乎无感知 | Redis可用，DB压力大 |
| Level 2 | 本地缓存 | 延迟5分钟 | 轻微感知 | Redis不可用 |
| Level 3 | 简化数据 | 延迟可能更长 | 明显感知 | 缓存都miss |
| Level 4 | 默认值/提示 | - | 功能不可用 | 完全失败 |

### 2.2 各级降级详解

**Level 1：Redis缓存降级**
```java
public ProductDTO getProduct(Long productId) {
    try {
        // 正常查询（聚合多个服务）
        return aggregateProductInfo(productId);
    } catch (Exception e) {
        // 降级到Redis缓存
        ProductDTO cached = redisCache.get("product:" + productId);
        if (cached != null) {
            cached.setFromCache(true);  // 标记来自缓存
            metrics.record("degrade.level1");
            return cached;
        }
        throw e;  // 继续向上抛，触发更高级别降级
    }
}
```

**Level 2：本地缓存降级**
```java
public ProductDTO getProductWithFallback(Long productId) {
    try {
        return getProduct(productId);
    } catch (Exception e) {
        // Redis也失败，降级到本地缓存
        ProductDTO localCached = localCache.get(productId);
        if (localCached != null) {
            localCached.setDataDelay("数据可能有延迟");
            metrics.record("degrade.level2");
            return localCached;
        }
        throw e;
    }
}
```

**Level 3：简化数据降级**
```java
public ProductDTO getProductSimplified(Long productId) {
    try {
        return getProductWithFallback(productId);
    } catch (Exception e) {
        // 只查询商品基础表，返回核心信息
        Product basic = productDao.selectBasicById(productId);
        if (basic != null) {
            ProductDTO simplified = new ProductDTO();
            simplified.setId(basic.getId());
            simplified.setName(basic.getName());
            simplified.setPrice(basic.getPrice());
            simplified.setImage(basic.getMainImage());
            simplified.setSimplified(true);  // 标记为简化数据
            metrics.record("degrade.level3");
            return simplified;
        }
        throw e;
    }
}
```

**Level 4：兜底降级**
```java
public ProductDTO getProductFinal(Long productId) {
    try {
        return getProductSimplified(productId);
    } catch (Exception e) {
        // 彻底失败，返回友好提示
        metrics.record("degrade.level4");
        log.error("Product query failed completely: {}", productId, e);

        ProductDTO fallback = new ProductDTO();
        fallback.setId(productId);
        fallback.setError(true);
        fallback.setErrorMsg("商品信息暂时无法加载，请稍后再试");
        return fallback;
    }
}
```

### 2.3 降级效果统计

| 降级级别 | 日常触发率 | 大促触发率 | 转化率影响 |
|---------|-----------|-----------|-----------|
| Level 1 | 5% | 15% | -0.5% |
| Level 2 | 0.5% | 3% | -2% |
| Level 3 | 0.05% | 0.5% | -10% |
| Level 4 | 0.005% | 0.05% | -100% |

---

## 三、熔断机制设计

### 3.1 为什么需要熔断？

**场景：下游服务故障**
- 评价服务挂了，每次调用超时3秒
- 如果不熔断，商品详情接口RT飙升
- 大量请求堆积，最终拖垮整个商品系统

**熔断的作用：**
- 快速失败，避免请求堆积
- 保护调用方，不被下游拖垮
- 给下游服务恢复的时间

### 3.2 熔断器状态机

```
                    错误率>阈值
        ┌─────────────────────────┐
        │                         ▼
    [关闭状态]                [打开状态]
    (正常调用)                (快速失败)
        ▲                         │
        │    成功率恢复           │ 等待超时
        │◄────────────────────────┤
        │                         ▼
        │                   [半开状态]
        └────────────────── (试探调用)
              试探成功
```

**状态说明：**
- **关闭（Closed）**：正常状态，所有请求都会执行
- **打开（Open）**：熔断状态，所有请求快速失败，不执行实际调用
- **半开（Half-Open）**：试探状态，放部分请求试探下游是否恢复

### 3.3 熔断参数配置

```java
@HystrixCommand(
    fallbackMethod = "getReviewsFallback",
    commandProperties = {
        // 熔断触发条件
        @HystrixProperty(name = "circuitBreaker.enabled", value = "true"),
        @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold",
                         value = "20"),    // 10秒内至少20个请求才统计
        @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage",
                         value = "50"),    // 错误率超过50%触发熔断
        @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds",
                         value = "10000"), // 熔断后10秒进入半开状态

        // 超时配置
        @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",
                         value = "200"),   // 超时时间200ms

        // 统计窗口
        @HystrixProperty(name = "metrics.rollingStats.timeInMilliseconds",
                         value = "10000")  // 10秒滑动窗口
    }
)
public List<Review> getReviews(Long productId) {
    return reviewService.getByProductId(productId);
}

public List<Review> getReviewsFallback(Long productId) {
    // 熔断后的降级逻辑
    return Collections.emptyList();  // 返回空评价
}
```

### 3.4 各服务熔断配置

| 依赖服务 | 超时时间 | 错误率阈值 | 熔断时间 | 降级策略 |
|---------|---------|-----------|---------|---------|
| 评价服务 | 200ms | 50% | 10s | 返回空列表 |
| 推荐服务 | 300ms | 50% | 10s | 返回热门商品 |
| 库存服务 | 100ms | 30% | 5s | 返回"库存充足" |
| 价格服务 | 100ms | 30% | 5s | 返回基础价格 |

**为什么库存和价格的阈值更低？**
- 这两个是核心链路，对准确性要求高
- 宁可快速熔断返回降级值，也不能返回错误数据
- 熔断后用缓存价格/库存兜底

---

## 四、自动降级 vs 人工降级

### 4.1 自动降级

**触发条件：**
```java
public class AutoDegradeManager {

    // 自动降级规则
    private List<DegradeRule> rules = Arrays.asList(
        // 规则1：错误率触发
        new DegradeRule()
            .setResource("getProductDetail")
            .setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO)
            .setCount(0.5)      // 错误率50%
            .setTimeWindow(10), // 10秒窗口

        // 规则2：RT触发
        new DegradeRule()
            .setResource("getProductDetail")
            .setGrade(RuleConstant.DEGRADE_GRADE_RT)
            .setCount(200)      // RT超过200ms
            .setTimeWindow(10),

        // 规则3：异常数触发
        new DegradeRule()
            .setResource("getProductDetail")
            .setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT)
            .setCount(10)       // 10秒内10个异常
            .setTimeWindow(10)
    );
}
```

**自动降级的优点：**
- 响应快，毫秒级触发
- 不依赖人工判断
- 7×24小时自动保护

**自动降级的局限：**
- 可能误判（短暂抖动也会触发）
- 无法感知业务上下文
- 降级策略相对固定

### 4.2 人工降级

**人工降级场景：**
1. **大促预降级**：提前关闭非核心功能
2. **紧急情况**：发现严重问题，一键降级
3. **计划内维护**：依赖服务升级时主动降级

**降级开关设计：**
```java
// 配置中心的降级开关
@ConfigurationProperties(prefix = "degrade.switch")
public class DegradeSwitch {

    // 全局降级开关
    private boolean globalEnabled = false;

    // 各功能降级开关
    private boolean reviewEnabled = true;    // 评价功能
    private boolean recommendEnabled = true; // 推荐功能
    private boolean videoEnabled = true;     // 视频功能
    private boolean highResImageEnabled = true; // 高清图片

    // 降级等级（1-4）
    private int degradeLevel = 0;
}
```

**一键降级控制台：**
```
┌─────────────────────────────────────────────────┐
│           商品系统降级控制台                      │
├─────────────────────────────────────────────────┤
│ 全局降级: [OFF] ← 一键开启                       │
│                                                 │
│ 功能降级开关:                                    │
│ ├─ 商品评价    [ON]  ← 关闭后返回空              │
│ ├─ 推荐商品    [ON]  ← 关闭后不展示              │
│ ├─ 商品视频    [ON]  ← 关闭后不加载              │
│ ├─ 高清大图    [ON]  ← 关闭后用缩略图            │
│ └─ 实时库存    [ON]  ← 关闭后用缓存库存          │
│                                                 │
│ 降级等级: [Level 0 ▼]                           │
│ ├─ Level 0: 正常                                │
│ ├─ Level 1: 缓存优先                            │
│ ├─ Level 2: 本地缓存                            │
│ └─ Level 3: 简化数据                            │
│                                                 │
│ [应用配置]  [重置]  [查看历史]                    │
└─────────────────────────────────────────────────┘
```

---

## 五、熔断恢复机制

### 5.1 恢复策略

**为什么不能直接恢复？**
- 下游服务刚恢复，可能还不稳定
- 如果瞬间放开全部流量，可能再次打挂
- 需要逐步恢复，给下游服务热身时间

**恢复过程：**
```
熔断状态 → 半开探测 → 灰度恢复 → 完全恢复

时间线：
0s      10s      20s      30s      60s      120s
|--------|--------|--------|--------|--------|
熔断    半开     10%      30%      50%     100%
        (探测)   流量     流量     流量     流量
```

### 5.2 恢复实现

```java
public class CircuitBreakerRecovery {

    private AtomicInteger successCount = new AtomicInteger(0);
    private volatile double currentRatio = 0.0;  // 当前放行比例

    // 半开状态探测
    public boolean allowProbe() {
        // 每10秒放一个请求探测
        return System.currentTimeMillis() % 10000 < 100;
    }

    // 探测成功后的处理
    public void onProbeSuccess() {
        int count = successCount.incrementAndGet();
        if (count >= 3) {
            // 连续3次成功，进入灰度恢复
            startGradualRecovery();
        }
    }

    // 灰度恢复
    private void startGradualRecovery() {
        // 10% → 30% → 50% → 100%
        double[] ratios = {0.1, 0.3, 0.5, 1.0};

        for (double ratio : ratios) {
            currentRatio = ratio;

            // 每个阶段观察30秒
            Thread.sleep(30000);

            // 检查这30秒的错误率
            if (getRecentErrorRate() > 0.1) {
                // 错误率超过10%，重新熔断
                tripCircuitBreaker();
                return;
            }
        }

        // 完全恢复
        closeCircuitBreaker();
    }

    // 判断请求是否放行
    public boolean shouldAllow() {
        if (isCircuitOpen()) {
            return allowProbe();
        }
        if (isHalfOpen()) {
            return Math.random() < currentRatio;
        }
        return true;
    }
}
```

### 5.3 恢复监控

```
熔断恢复监控大盘：
┌──────────────────────────────────────────────────┐
│ 服务: ReviewService                              │
│ 状态: 半开 (灰度恢复中)                           │
│ 当前放行比例: 30%                                 │
│                                                  │
│ 恢复进度:                                         │
│ [████████████░░░░░░░░░░░░] 30%                   │
│                                                  │
│ 最近30秒指标:                                     │
│ - 请求数: 150                                    │
│ - 成功数: 145                                    │
│ - 错误率: 3.3%                                   │
│ - 平均RT: 85ms                                   │
│                                                  │
│ 预计完全恢复时间: 2分钟后                         │
└──────────────────────────────────────────────────┘
```

---

## 六、降级的业务兜底

### 6.1 数据兜底策略

**评价数据降级：**
```java
public List<Review> getReviewsWithFallback(Long productId) {
    try {
        return reviewService.getReviews(productId);
    } catch (Exception e) {
        // 降级策略1：返回缓存的评价
        List<Review> cached = reviewCache.get(productId);
        if (cached != null) {
            return cached;
        }

        // 降级策略2：返回"暂无评价"
        return Collections.singletonList(
            new Review().setContent("暂无评价，成为第一个评价的人吧")
        );
    }
}
```

**库存数据降级：**
```java
public StockInfo getStockWithFallback(Long productId) {
    try {
        return stockService.getStock(productId);
    } catch (Exception e) {
        // 降级策略：返回"库存充足"
        // 原因：宁可超卖后补货，也不能因为库存服务故障导致无法下单
        StockInfo fallback = new StockInfo();
        fallback.setProductId(productId);
        fallback.setAvailable(true);
        fallback.setQuantity(999);  // 虚拟库存
        fallback.setFromFallback(true);  // 标记为降级数据

        log.warn("Stock service degraded for product: {}", productId);
        return fallback;
    }
}
```

### 6.2 页面展示兜底

**商品详情页降级展示：**
```
正常状态：
┌─────────────────────────┐
│ [商品图片]              │
│ 商品名称                │
│ ￥29.9                  │
│ 已售 1234份             │
│ ★★★★☆ 4.5分 (328条评价) │
│ [详细描述...]           │
│ [用户评价...]           │
│ [推荐商品...]           │
└─────────────────────────┘

降级状态（Level 2）：
┌─────────────────────────┐
│ [商品图片-缩略图]       │
│ 商品名称                │
│ ￥29.9                  │
│ ⚠️ 数据可能有延迟        │
│ [评价加载中...]         │
│ [推荐加载中...]         │
└─────────────────────────┘

降级状态（Level 3）：
┌─────────────────────────┐
│ [默认图片]              │
│ 商品名称                │
│ ￥29.9                  │
│ [立即购买]              │
│ (仅显示核心信息)        │
└─────────────────────────┘
```

---

## 七、实战案例

### 7.1 案例1：评价服务雪崩

**事故背景：**
- 某次大促，评价服务数据库被打满
- 评价服务RT从50ms飙升到5秒
- 商品详情接口被拖慢，用户大量投诉

**处理过程：**
```
11:30 - 监控告警：评价服务RT > 500ms
11:31 - 熔断器自动触发，评价服务被熔断
11:31 - 商品详情接口RT恢复正常，返回空评价
11:35 - 值班人员确认，开启人工降级开关
11:45 - 评价服务DBA扩容完成
11:50 - 熔断器进入半开状态，开始探测
12:00 - 灰度恢复到50%
12:10 - 完全恢复，关闭人工降级开关
```

**复盘改进：**
- 评价服务增加限流，防止被大流量打挂
- 商品详情接口对评价的依赖改为异步加载
- 增加评价数据的本地缓存

### 7.2 案例2：大促预降级

**场景：双11大促**

**预降级策略：**
```
大促前1天：
- 关闭商品视频功能（节省带宽）
- 关闭实时推荐（降低计算压力）
- 评价只展示前10条（减少DB查询）

大促期间：
- 全局降级等级设为Level 1（优先读缓存）
- 缓存TTL从30秒延长到5分钟
- 关闭所有非核心定时任务

大促后：
- 逐步恢复各项功能
- 先恢复推荐，再恢复视频
- 最后恢复到Level 0
```

**效果：**
- 系统平稳度过流量高峰
- 核心指标（下单成功率）保持99.9%
- 用户投诉量比上次大促降低60%

---

## 八、最佳实践总结

### 8.1 降级设计原则

1. **核心链路不降级**：影响下单的功能，宁可慢也要准
2. **用户感知最小化**：尽量返回有价值的信息
3. **降级要可观测**：监控降级次数、级别、原因
4. **降级要可恢复**：不能只降不升

### 8.2 熔断配置原则

1. **超时要短**：宁可快速失败，也不要长时间等待
2. **阈值要合理**：太低容易误熔断，太高保护不住
3. **恢复要渐进**：不能瞬间放开全部流量
4. **依赖要分级**：核心依赖和非核心依赖配置不同

### 8.3 踩过的坑

**坑1：降级后忘记恢复**
- 某次故障后开启了人工降级
- 故障恢复后忘记关闭
- 导致评价功能关闭了一周才被发现
- 教训：降级开关要有过期时间，超时自动恢复

**坑2：熔断恢复太快**
- 下游服务刚恢复就放开全部流量
- 结果又被打挂，反复熔断
- 教训：必须灰度恢复

**坑3：降级数据被当成真实数据**
- 库存降级返回"充足"
- 订单系统把降级数据当成真实库存
- 导致大量超卖
- 教训：降级数据必须有标记，下游要识别
