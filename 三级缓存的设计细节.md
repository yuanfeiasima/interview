# 三级缓存的设计细节

## 核心要点（面试快速回答）

**Q: 三级缓存的命中率为什么是这个比例？**
L1本地缓存30%、L2 Redis 60%、L3 DB 10%。这是基于访问热度的自然分布：热点数据（Top 10%商品）占90%访问量，放L1；次热数据（Top 30%）占9%访问量，放L2；长尾数据走DB。

**Q: 本地缓存如何更新？**
两种方式：1）被动失效（TTL 30秒）；2）主动刷新（Canal监听binlog，通过MQ广播到所有机器）。关键数据用主动刷新，普通数据用被动失效。

**Q: 如何避免本地缓存不一致？**
容忍短时不一致（30秒内）。对于强一致性要求的场景（如价格、库存），不走本地缓存，直接查Redis或DB。对于可以接受延迟的场景（如商品详情），30秒延迟可接受。

**Q: 命中率如何统计？**
在缓存查询的每一层埋点统计，记录到监控系统。公式：L1命中率 = L1命中次数 / 总查询次数。实时监控，按小时、天、周聚合分析。

---

## 一、三级缓存架构设计

### 1.1 为什么需要三级缓存？

**单级缓存的问题：**
- 只用Redis：网络开销大（RT 5ms），百万QPS压力大
- 只用本地缓存：容量有限，命中率低，一致性难保证

**三级缓存的优势：**
- L1本地缓存：极致性能（RT 1ms），减少网络开销
- L2 Redis：容量大，命中率高，多机共享
- L3 DB：兜底，保证数据完整性

### 1.2 三级缓存的数据分布

```
L1 本地缓存（Caffeine）：
- 容量：每台机器10GB
- 数据：热点商品（约100万个）
- 命中率：30%
- RT：1ms

L2 Redis集群：
- 容量：2TB
- 数据：活跃商品（约5000万个）
- 命中率：60%
- RT：5ms

L3 MySQL：
- 容量：50TB
- 数据：全量商品（50亿）
- 命中率：10%
- RT：20ms
```


---

## 二、命中率统计与分析

### 2.1 命中率统计方法

**埋点统计：**
```java
public Product getProduct(Long productId) {
    // L1 查询
    Product product = localCache.get(productId);
    if (product != null) {
        metrics.record("cache.l1.hit");
        return product;
    }
    metrics.record("cache.l1.miss");
    
    // L2 查询
    product = redisCache.get(productId);
    if (product != null) {
        metrics.record("cache.l2.hit");
        localCache.put(productId, product);
        return product;
    }
    metrics.record("cache.l2.miss");
    
    // L3 查询
    product = dbDao.query(productId);
    metrics.record("cache.l3.query");
    
    // 回填缓存
    redisCache.put(productId, product);
    localCache.put(productId, product);
    
    return product;
}
```


### 2.2 为什么是这个命中率比例？

**基于访问热度的自然分布：**

**热点数据（Top 10%）：**
- 占总访问量的90%
- 典型：爆款商品、热门餐厅
- 放在L1本地缓存

**次热数据（Top 30%）：**
- 占总访问量的9%
- 典型：常规热销商品
- 放在L2 Redis

**长尾数据（剩余70%）：**
- 占总访问量的1%
- 典型：冷门商品、历史商品
- 走L3 DB

**实际验证：**
- 统计了1个月的访问日志
- 符合二八定律（甚至更极端）
- 验证了缓存分层的合理性


---

## 三、本地缓存更新策略

### 3.1 两种更新方式

**方式1：被动失效（TTL）**
- 设置过期时间30秒
- 到期自动失效
- 下次查询时重新加载
- 适用场景：普通商品信息

**方式2：主动刷新（Canal+MQ）**
- Canal监听MySQL binlog
- 发送更新消息到MQ
- 所有机器订阅MQ，更新本地缓存
- 适用场景：关键数据（价格、状态）


### 3.2 主动刷新的实现

**Canal监听binlog：**
```java
@CanalListener(destination = "product_db")
public void onDataChange(CanalEntry.Entry entry) {
    if (entry.getEntryType() == EntryType.ROWDATA) {
        RowChange rowChange = parseEntry(entry);
        
        for (RowData rowData : rowChange.getRowDatasList()) {
            Long productId = getProductId(rowData);
            
            // 发送刷新消息
            CacheRefreshMessage message = new CacheRefreshMessage();
            message.setProductId(productId);
            message.setAction(rowChange.getEventType());
            
            mqProducer.send("cache_refresh_topic", message);
        }
    }
}
```


**消费MQ，刷新本地缓存：**
```java
@RocketMQMessageListener(topic = "cache_refresh_topic")
public void onMessage(CacheRefreshMessage message) {
    Long productId = message.getProductId();
    
    if (message.getAction() == EventType.DELETE) {
        // 删除本地缓存
        localCache.invalidate(productId);
    } else {
        // 从Redis加载最新数据
        Product product = redisCache.get(productId);
        if (product != null) {
            localCache.put(productId, product);
        }
    }
}
```


---

## 四、如何避免本地缓存不一致

### 4.1 不一致的场景

**场景1：更新延迟**
- 数据库更新后，MQ消息延迟
- 不同机器收到消息的时间不同
- 短时间内不同机器看到的数据不一致

**场景2：消息丢失**
- MQ消息丢失
- 某些机器没有收到刷新消息
- 本地缓存一直是旧数据


### 4.2 解决方案

**方案1：容忍短时不一致**
- TTL设置为30秒
- 最多30秒后数据会自动刷新
- 对于商品详情等场景，30秒延迟可接受

**方案2：强一致性场景不走本地缓存**
- 价格、库存等关键数据
- 直接查Redis或DB
- 保证强一致性

**方案3：版本号机制**
- 每次更新数据时version+1
- 本地缓存存储version
- 查询时对比version，不一致则刷新


**方案4：定期全量刷新**
- 每小时全量刷新一次热点数据
- 兜底机制，防止数据长期不一致
- 对性能影响小

---

## 五、缓存容量规划

### 5.1 本地缓存容量

**容量计算：**
- 单个商品对象：10KB
- 单机缓存100万个商品
- 总容量：10GB

**为什么是100万？**
- 基于热点数据统计
- Top 100万商品占90%访问量
- 平衡内存占用和命中率


### 5.2 Redis容量

**容量计算：**
- 缓存5000万活跃商品
- 单个商品：10KB
- 总容量：500GB
- 加上副本和缓冲：2TB

---

## 六、性能优化

### 6.1 本地缓存优化

**使用Caffeine：**
- 比Guava Cache性能更好
- 支持异步加载
- 自动淘汰策略（LRU）

**预热机制：**
- 应用启动时预加载热点数据
- 避免冷启动时大量请求打到DB


### 6.2 Redis优化

**批量查询：**
- 使用Pipeline批量获取
- 减少网络往返次数
- 性能提升3-5倍

**连接池优化：**
- 合理设置连接池大小
- 避免连接耗尽

---

## 七、监控与告警

### 7.1 关键指标

**命中率监控：**
- L1命中率：目标>30%
- L2命中率：目标>60%
- 总命中率：目标>90%

**性能监控：**
- L1查询延迟：P99<2ms
- L2查询延迟：P99<10ms
- L3查询延迟：P99<50ms


### 7.2 告警规则

**命中率告警：**
- L1命中率<25%：检查热点数据分布
- L2命中率<50%：检查Redis容量
- 总命中率<85%：紧急告警

**性能告警：**
- L1延迟>5ms：检查本地缓存
- L2延迟>20ms：检查Redis集群
- L3延迟>100ms：检查数据库

---

## 八、实施效果

**性能提升：**
- 平均查询延迟：从20ms降到3ms
- P99延迟：从50ms降到10ms
- DB压力：降低90%

**成本优化：**
- 减少Redis集群规模20%
- 减少DB连接数50%
- 整体成本降低15%
