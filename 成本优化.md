# 成本优化

## 核心要点（面试快速回答）

**Q: 4000+台服务器做过哪些成本优化？**
三个主要方向：1）计算资源优化：弹性扩缩容节省40%机器成本，高峰期按需扩容，低谷期缩容；2）存储成本优化：冷热分离节省60%存储成本，热数据SSD，温数据HDD，冷数据对象存储；3）缓存优化：提升缓存命中率减少DB压力，DB实例减少30%。

**Q: 缓存命中率提升怎么做的？**
三个手段：1）增加本地缓存层，命中率从0提升到30%；2）热点数据预热，启动时加载Top 10万商品；3）缓存key设计优化，减少热点分片问题。整体缓存命中率从85%提升到95%，DB QPS降低60%。

**Q: 机器资源利用率怎么优化？**
两个方面：1）混部：把CPU密集型（商品服务）和IO密集型（日志服务）部署在同一台机器，利用率从30%提升到65%；2）弹性扩缩容：根据流量自动调整实例数，避免资源闲置。

**Q: 效果如何量化？**
年化成本降低约35%，具体：机器成本降40%（弹性+混部），存储成本降60%（冷热分离），带宽成本降20%（CDN+压缩）。节省的成本相当于每年数千万元。

---

## 一、成本构成分析

### 1.1 成本全景

```
商品系统成本构成：

总成本 = 计算成本 + 存储成本 + 网络成本 + 其他成本

计算成本（50%）：
├─ 应用服务器：4000+台
├─ 缓存服务器：500+台
└─ 数据库服务器：200+台

存储成本（30%）：
├─ 数据库存储：50TB
├─ 缓存存储：2TB
├─ 对象存储：100TB
└─ 日志存储：200TB

网络成本（15%）：
├─ 带宽费用
├─ CDN费用
└─ 跨机房流量

其他成本（5%）：
├─ 监控系统
├─ 日志系统
└─ 运维工具
```

### 1.2 优化目标

```
成本优化目标：

1. 降低成本
   - 计算成本降低40%
   - 存储成本降低50%
   - 整体成本降低35%

2. 不影响性能
   - RT不增加
   - 可用性不降低
   - 用户体验不受影响

3. 不增加复杂度
   - 运维复杂度可控
   - 故障恢复能力不降
```

---

## 二、计算资源优化

### 2.1 弹性扩缩容

**固定容量的浪费**：外卖业务有明显的潮汐效应，午高峰和晚高峰流量是平时的5倍。如果按峰值配置机器，80%的时间资源都在闲置。弹性扩缩容根据实时负载自动调整实例数，实现"用多少买多少"。

**扩缩容策略的关键参数**：
- 扩容阈值：CPU>70%或QPS>容量80%，触发扩容
- 缩容阈值：CPU<30%持续10分钟，触发缩容
- 扩容幅度：最多扩容50%，避免过度扩容
- 缩容要谨慎：需要持续低负载才缩容，避免频繁抖动

```java
// 扩缩容策略
@Component
public class AutoScalingService {

    // 扩容触发条件
    private static final double SCALE_UP_CPU_THRESHOLD = 0.7;  // CPU > 70%
    private static final double SCALE_UP_QPS_THRESHOLD = 0.8;  // QPS > 容量80%

    // 缩容触发条件
    private static final double SCALE_DOWN_CPU_THRESHOLD = 0.3;  // CPU < 30%
    private static final int SCALE_DOWN_DURATION = 600;  // 持续10分钟

    @Scheduled(fixedRate = 60000)  // 每分钟检查
    public void checkAndScale() {
        ClusterMetrics metrics = metricsService.getClusterMetrics();

        if (shouldScaleUp(metrics)) {
            int targetCount = calculateScaleUpTarget(metrics);
            scaleUp(targetCount);
        } else if (shouldScaleDown(metrics)) {
            int targetCount = calculateScaleDownTarget(metrics);
            scaleDown(targetCount);
        }
    }

    private int calculateScaleUpTarget(ClusterMetrics metrics) {
        // 根据当前负载计算目标实例数
        double currentLoad = metrics.getAverageCpuUsage();
        int currentCount = metrics.getInstanceCount();

        // 目标：让CPU使用率降到50%
        int targetCount = (int) (currentCount * currentLoad / 0.5);

        // 最多扩容50%
        return Math.min(targetCount, (int) (currentCount * 1.5));
    }
}
```

**实际效果：**
```
扩缩容效果：

时间段         | 实例数  | CPU利用率 | 成本
-------------|--------|----------|------
高峰期(11-14) | 3000   | 65%      | 100%
平峰期(14-17) | 1500   | 60%      | 50%
低谷期(0-6)   | 800    | 50%      | 27%

平均成本节省：40%
```

### 2.2 资源混部

**为什么混部**：不同类型服务的资源消耗特征不同。CPU密集型服务（商品服务）CPU高、内存低；IO密集型服务（日志服务）CPU低、IO高。单独部署时各有闲置资源，混部后可以互补利用。

**混部原则**：
1. CPU密集型 + IO密集型：资源互补
2. 在线服务 + 离线任务：时间错开
3. 计算服务 + 缓存服务：资源互补

**注意事项**：
- 设置资源限制（limits），避免互相影响
- 设置亲和性规则，避免同类服务部署在一起
- 监控资源使用，及时调整配比

```yaml
# K8s 混部配置示例
apiVersion: v1
kind: Pod
metadata:
  name: mixed-workload
spec:
  containers:
  # CPU密集型服务
  - name: product-service
    resources:
      requests:
        cpu: "2"
        memory: "4Gi"
      limits:
        cpu: "4"
        memory: "8Gi"

  # IO密集型服务
  - name: log-processor
    resources:
      requests:
        cpu: "0.5"
        memory: "2Gi"
      limits:
        cpu: "1"
        memory: "4Gi"

  # 亲和性设置，避免同类服务部署在一起
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchLabels:
              type: cpu-intensive
```

**混部策略：**
```
混部组合推荐：

组合1：商品服务 + 日志处理
- 商品服务消耗CPU
- 日志处理消耗IO
- 错峰使用，互不干扰

组合2：在线服务 + 离线任务
- 在线服务高峰期活跃
- 离线任务夜间运行
- 时间错开，充分利用

组合3：计算服务 + 缓存服务
- 计算服务消耗CPU
- 缓存服务消耗内存
- 资源互补
```

**效果：**
```
混部效果：

指标        | 混部前  | 混部后  | 提升
-----------|--------|--------|-----
CPU利用率   | 30%    | 65%    | +117%
内存利用率  | 40%    | 70%    | +75%
机器数量    | 4000   | 2800   | -30%
```

### 2.3 服务瘦身

```java
// 减少不必要的依赖
// 优化前：商品服务依赖30个jar包
// 优化后：移除不必要的依赖，减少到18个

// 内存优化
// 优化前：-Xmx8g
// 优化后：-Xmx4g（配合G1 GC优化）

// 线程池优化
// 优化前：固定大小线程池，200线程
// 优化后：弹性线程池，核心50，最大200

// 连接池优化
// 优化前：每个DB连接池200连接
// 优化后：根据实际QPS调整为50-100
```

---

## 三、存储成本优化

### 3.1 冷热数据分离

**数据分布的特点**：百亿数据中，真正被频繁访问的（热数据）只有10%，另外30%偶尔被访问（温数据），60%基本不访问（冷数据）。如果全部用高性能SSD存储，成本非常高。

**分层存储策略**：
- 热数据（近3月活跃）→ SSD：访问多，需要低延迟
- 温数据（3-12月）→ HDD：访问少，可以接受稍高延迟
- 冷数据（12月以上）→ 对象存储（OSS）：几乎不访问，成本最低

**存储成本对比**：
- SSD：100%/TB
- HDD：30%/TB
- OSS：10%/TB
分层后存储成本降低60%。

**数据迁移策略：**
```java
// 定时数据归档任务
@Scheduled(cron = "0 0 3 * * ?")  // 每天凌晨3点
public void archiveData() {
    Date warmThreshold = DateUtils.addMonths(new Date(), -3);
    Date coldThreshold = DateUtils.addMonths(new Date(), -12);

    // 热数据 -> 温数据
    List<Long> toWarmIds = productDao.selectIdsByLastAccessBefore(warmThreshold);
    for (Long productId : toWarmIds) {
        migrateToWarmStorage(productId);
    }

    // 温数据 -> 冷数据
    List<Long> toColdIds = warmStorageDao.selectIdsByLastAccessBefore(coldThreshold);
    for (Long productId : toColdIds) {
        migrateToColdStorage(productId);
    }
}

// 查询时自动路由
public Product getProduct(Long productId) {
    // 先查热数据
    Product product = hotStorageDao.selectById(productId);
    if (product != null) {
        return product;
    }

    // 再查温数据
    product = warmStorageDao.selectById(productId);
    if (product != null) {
        // 如果被访问，考虑提升为热数据
        maybePromoteToHot(product);
        return product;
    }

    // 最后查冷数据
    return coldStorageDao.selectById(productId);
}
```

**效果：**
```
冷热分离效果：

存储类型  | 数据量 | 单价  | 成本    | 节省
---------|-------|------|---------|-----
全SSD    | 50TB  | ¥100 | ¥5000/月 | -
分层存储  | -     | -    | ¥2000/月 | 60%
├─ SSD   | 10TB  | ¥100 | ¥1000   |
├─ HDD   | 30TB  | ¥30  | ¥900    |
└─ OSS   | 60TB  | ¥2   | ¥120    |
```

### 3.2 数据压缩

```java
// JSON压缩存储
public void saveProductExt(Long productId, Map<String, Object> ext) {
    String json = JSON.toJSONString(ext);

    // 压缩
    byte[] compressed = Snappy.compress(json.getBytes(StandardCharsets.UTF_8));

    // 压缩率通常在30%-50%
    extDao.save(productId, compressed);
}

// Redis数据压缩
public void cacheProduct(Product product) {
    // 使用Protobuf序列化，比JSON小70%
    byte[] data = product.toProtobuf().toByteArray();
    redisTemplate.opsForValue().set("product:" + product.getId(), data);
}
```

### 3.3 索引优化

```sql
-- 删除冗余索引
-- 发现idx_create_time和idx_merchant_create_time重复
DROP INDEX idx_create_time ON product;

-- 合并相似索引
-- 优化前
INDEX idx_merchant (merchant_id)
INDEX idx_merchant_status (merchant_id, status)

-- 优化后：保留复合索引，删除单列索引
DROP INDEX idx_merchant ON product;

-- 索引存储优化效果
-- 索引大小从15GB降到10GB
-- 写入性能提升20%
```

---

## 四、缓存优化

### 4.1 提升缓存命中率

**缓存命中率与成本的关系**：缓存命中率每提升1%，就有更多请求不用打到DB，DB压力降低，可以减少DB实例。我们通过三个手段把命中率从85%提升到95%，DB QPS降低67%，减少了30%的DB实例。

**三个优化手段**：
1. 增加本地缓存层：把极热数据放在应用内存，比Redis还快
2. 热点数据预热：启动时加载Top 10万商品，避免冷启动
3. 缓存Key优化：加入商家ID前缀，分散热点到不同分片

```java
// 1. 增加本地缓存层
@Bean
public Cache<Long, Product> localCache() {
    return Caffeine.newBuilder()
        .maximumSize(1_000_000)  // 100万条
        .expireAfterWrite(30, TimeUnit.SECONDS)
        .recordStats()
        .build();
}

// 2. 热点数据预热
@PostConstruct
public void warmUp() {
    // 启动时预热Top 10万热点商品
    List<Long> hotProductIds = analyticsService.getTop100kProducts();
    Map<Long, Product> products = productDao.batchSelect(hotProductIds);

    for (Map.Entry<Long, Product> entry : products.entrySet()) {
        localCache.put(entry.getKey(), entry.getValue());
        redisCache.put("product:" + entry.getKey(), entry.getValue());
    }
}

// 3. 缓存Key优化，避免热点
public String getCacheKey(Long productId) {
    // 加入商家ID前缀，分散热点
    Long merchantId = getMerchantId(productId);
    return "product:" + (merchantId % 100) + ":" + productId;
}
```

**优化后效果：**
```
缓存命中率对比：

层级    | 优化前 | 优化后 | 作用
--------|-------|-------|-----
本地缓存 | 0%    | 30%   | 极热数据
Redis   | 85%   | 65%   | 热数据
DB      | 15%   | 5%    | 冷数据

总命中率：85% -> 95%
DB QPS：15万 -> 5万（降低67%）
```

### 4.2 缓存容量优化

```java
// 差异化TTL策略
public void cacheProduct(Product product) {
    int ttl;

    if (isHotProduct(product.getId())) {
        ttl = 300;  // 热门商品5分钟
    } else if (isActiveProduct(product)) {
        ttl = 180;  // 活跃商品3分钟
    } else {
        ttl = 60;   // 普通商品1分钟
    }

    redisTemplate.opsForValue().set(
        "product:" + product.getId(),
        product,
        ttl,
        TimeUnit.SECONDS);
}

// 结果：
// 缓存容量从3TB降到2TB
// 命中率保持不变
```

---

## 五、网络成本优化

### 5.1 响应压缩

```java
// 开启Gzip压缩
@Configuration
public class CompressionConfig {

    @Bean
    public FilterRegistrationBean<GzipFilter> gzipFilter() {
        FilterRegistrationBean<GzipFilter> bean = new FilterRegistrationBean<>();
        bean.setFilter(new GzipFilter());
        bean.addUrlPatterns("/api/*");
        bean.setOrder(1);
        return bean;
    }
}

// 压缩效果：
// 商品列表响应：50KB -> 15KB（70%压缩率）
// 带宽节省：60%
```

### 5.2 CDN优化

```
CDN策略：

静态资源：
├─ 商品图片 -> CDN
├─ 商品视频 -> CDN
└─ 前端资源 -> CDN

动态接口：
├─ 商品列表 -> 边缘缓存（30秒TTL）
├─ 商品详情 -> 边缘缓存（60秒TTL）
└─ 价格库存 -> 不缓存

效果：
- 回源率从40%降到15%
- 带宽成本降低50%
```

### 5.3 跨机房优化

```
SET化部署效果：

优化前：
- 跨机房调用占比：30%
- 跨机房延迟：30ms
- 跨机房带宽成本：高

优化后（SET内闭环）：
- 跨机房调用占比：5%
- 大部分请求在SET内完成
- 跨机房带宽成本降低80%
```

---

## 六、成本优化效果汇总

### 6.1 各项优化效果

| 优化项 | 措施 | 节省比例 |
|-------|-----|---------|
| 计算资源 | 弹性扩缩容 | 40% |
| 计算资源 | 混部 | 30% |
| 存储成本 | 冷热分离 | 60% |
| 存储成本 | 数据压缩 | 20% |
| 缓存成本 | 命中率提升 | 30%（减少DB）|
| 网络成本 | CDN+压缩 | 50% |

### 6.2 整体成本变化

```
成本优化前后对比：

类别      | 优化前(月) | 优化后(月) | 节省
---------|-----------|-----------|-----
计算资源  | ¥800万    | ¥480万    | 40%
存储资源  | ¥300万    | ¥120万    | 60%
网络带宽  | ¥150万    | ¥100万    | 33%
其他     | ¥50万     | ¥50万     | 0%
---------|-----------|-----------|-----
总计     | ¥1300万   | ¥750万    | 42%

年化节省：约6600万元
```

---

## 七、成本治理体系

### 7.1 成本监控

```java
// 成本监控指标
public class CostMetrics {

    // 资源利用率监控
    private Gauge cpuUtilization = Gauge.builder()
        .name("resource_cpu_utilization")
        .tag("service", "product")
        .register(registry);

    // 存储成本监控
    private Gauge storageCost = Gauge.builder()
        .name("storage_cost_yuan")
        .tag("type", "hot")  // hot/warm/cold
        .register(registry);

    // 缓存效率监控
    private Gauge cacheHitRate = Gauge.builder()
        .name("cache_hit_rate")
        .tag("level", "l1")  // l1/l2
        .register(registry);
}
```

### 7.2 成本告警

```yaml
# 成本告警规则
alerts:
  - name: LowCpuUtilization
    condition: cpu_utilization < 0.3
    for: 30m
    message: "CPU利用率过低，考虑缩容"

  - name: HighStorageCost
    condition: storage_cost_increase > 0.2
    for: 1d
    message: "存储成本增长超过20%"

  - name: LowCacheHitRate
    condition: cache_hit_rate < 0.9
    for: 10m
    message: "缓存命中率下降，检查缓存策略"
```

### 7.3 成本治理流程

```
成本治理闭环：

1. 监控（Monitor）
   └─ 实时监控资源使用和成本

2. 分析（Analyze）
   └─ 周度成本分析报告
   └─ 识别优化空间

3. 优化（Optimize）
   └─ 制定优化方案
   └─ 实施优化措施

4. 验证（Verify）
   └─ 验证优化效果
   └─ 评估对业务影响

5. 固化（Standardize）
   └─ 形成最佳实践
   └─ 推广到其他系统
```

---

## 八、最佳实践

### 8.1 成本优化原则

```
1. 业务优先
   - 不能因为省钱影响业务
   - 性能和可用性是底线
   - 用户体验不能下降

2. 数据驱动
   - 基于数据做决策
   - 有监控才能优化
   - 量化优化效果

3. 持续优化
   - 成本优化是持续过程
   - 定期review和调整
   - 跟踪新技术和方案

4. 风险可控
   - 优化措施要可回滚
   - 灰度验证后再推广
   - 有应急预案
```

### 8.2 避坑指南

```
坑1：过度优化导致可用性下降
- 缩容太激进，高峰期扛不住
- 缓存TTL太长，数据不一致
- 教训：要留安全余量

坑2：只看单项成本，忽视整体
- 存储省了，但查询变慢，计算成本增加
- 要从全局优化，不是局部

坑3：优化后不持续跟踪
- 优化效果会衰减
- 业务变化会影响优化效果
- 需要持续监控和调整
```
