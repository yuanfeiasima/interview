# 缓存一致性方案

## 核心要点（面试快速回答）

**Q: 为什么选择最终一致性？**
因为强一致性代价太大。如果每次写DB后同步更新缓存，需要分布式事务，性能差且复杂。外卖场景下，商品信息延迟几秒可接受，用户无感知。

**Q: 不一致窗口多长？**
正常情况50-200ms（Canal延迟+MQ延迟）。极端情况（Canal故障）最长5分钟，通过定时全量校验兜底。

**Q: Canal延迟或消息丢失怎么办？**
三层保障：1）实时补偿（同步失败记录补偿表，定时重试）；2）全量校验（每天凌晨对比MySQL和Redis）；3）版本号机制（防止乱序更新）。

**Q: 有没有强一致性场景？**
有。价格、库存等关键数据，采用"先删缓存，再写DB"策略，查询时强制走DB，保证强一致。

---

## 一、为什么选择最终一致性

### 1.1 强一致性的代价

**方案1：先写DB，再写缓存**
- 问题：写缓存失败怎么办？
- 需要分布式事务保证
- 性能差，复杂度高

**方案2：先写缓存，再写DB**
- 问题：写DB失败怎么办？
- 缓存和DB不一致
- 更危险

**方案3：分布式事务（2PC/TCC）**
- 性能差（RT增加50%+）
- 复杂度高
- 不适合高并发场景


### 1.2 最终一致性的优势

**性能好：**
- 异步更新，不阻塞主流程
- 写入性能提升80%

**复杂度低：**
- 不需要分布式事务
- 实现简单

**可接受性：**
- 外卖场景下，商品信息延迟几秒可接受
- 用户无感知

---


## 二、Canal + MQ 异步刷新方案

### 2.1 整体架构

```
MySQL binlog → Canal → RocketMQ → 缓存刷新服务 → Redis
```

**为什么加MQ？**
- 解耦：Canal和缓存服务解耦
- 削峰：高峰期缓冲
- 重试：消息失败可重试
- 广播：多个消费者同时更新


### 2.2 同步延迟分析

**正常情况：**
- Canal监听延迟：20-50ms
- MQ传输延迟：10-30ms
- 缓存更新延迟：10-20ms
- 总延迟：50-100ms

**高峰期：**
- Canal延迟：50-100ms
- MQ延迟：50-100ms
- 总延迟：100-200ms

**极端情况（Canal故障）：**
- 最长延迟：5分钟
- 通过定时全量校验兜底


---

## 三、三层保障机制

### 3.1 实时补偿机制

**原理：**
- 同步失败时记录到补偿表
- 定时任务扫描补偿表
- 重新从MySQL查询数据
- 更新到Redis

**补偿频率：**
- 每分钟扫描一次
- 最多重试3次
- 超过3次人工介入


### 3.2 全量校验机制

**原理：**
- 每天凌晨3点执行
- 从MySQL分页查询所有商品
- 与Redis对比
- 发现不一致自动修复

**校验范围：**
- 核心字段：价格、状态、库存
- 非核心字段：描述、图片等（不校验）


### 3.3 版本号机制

**原理：**
- MySQL表增加version字段
- 每次更新version+1
- Redis存储时也存version
- 更新时对比version，只有新版本才更新

**作用：**
- 防止乱序更新
- 并发更新时保证最终一致

---


## 四、强一致性场景

### 4.1 哪些场景需要强一致性？

**关键数据：**
- 价格：用户下单时价格必须准确
- 库存：防止超卖
- 状态：商品上下架状态

**非关键数据：**
- 商品描述：延迟可接受
- 图片：延迟可接受
- 评价：延迟可接受


### 4.2 强一致性方案

**方案：先删缓存，再写DB**

**流程：**
1. 删除Redis缓存
2. 写入MySQL
3. 查询时发现缓存不存在
4. 从DB查询最新数据
5. 回填缓存

**优点：**
- 保证强一致性
- 实现简单

**缺点：**
- 性能略差（多一次DB查询）
- 适用于低频更新场景


---

## 五、实际效果

**一致性指标：**
- 数据一致性：99.99%
- 不一致窗口：平均100ms
- 每天补偿数据：< 1000条

**性能指标：**
- 写入性能：提升80%
- 查询延迟：无影响
- 系统可用性：99.95%

**成本：**
- Canal集群：10台
- MQ集群：20台
- 运维成本：中等
