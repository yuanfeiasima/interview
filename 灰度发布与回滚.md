# 灰度发布与回滚

## 核心要点（面试快速回答）

**Q: 商品系统如何做灰度发布？**
三种灰度策略组合使用：1）按流量灰度（先1%→5%→20%→100%）；2）按地域灰度（先小城市→再大城市）；3）按商家灰度（先内部测试商家→再普通商家→最后头部商家）。每个阶段观察30分钟无异常再继续。

**Q: 灰度过程中发现问题如何回滚？**
秒级回滚能力：流量切换在网关层做，切换只需修改路由规则，10秒内生效。回滚不需要重新部署，直接切换流量到旧版本。数据层面：如果有数据变更，通过补偿任务修复。

**Q: 数据兼容性如何处理？**
发布前必须做兼容性检查：1）数据库变更要向后兼容（加字段可以，改字段类型不行）；2）接口变更要向后兼容（新增字段可以，删除字段不行）；3）不兼容的变更要分多次发布。

**Q: 有没有灰度过程中出问题的案例？**
有。一次发布引入了慢SQL，灰度到20%时发现DB压力异常。立即回滚，排查发现是新代码的查询缺少索引。后来增加了SQL审核卡点，上线前必须经过DBA审核。

---

## 一、灰度发布整体方案

### 1.1 发布流程概览

```
发布流程：

代码合并 → CI构建 → 部署测试环境 → 测试验证
    ↓
灰度发布（生产环境）
    ├─ 第一阶段：1%流量（5台机器）
    │   └─ 观察30分钟，检查核心指标
    ├─ 第二阶段：5%流量（25台机器）
    │   └─ 观察30分钟
    ├─ 第三阶段：20%流量（100台机器）
    │   └─ 观察30分钟
    ├─ 第四阶段：50%流量
    │   └─ 观察30分钟
    └─ 第五阶段：100%全量
    ↓
发布完成，旧版本下线
```

### 1.2 灰度策略矩阵

| 变更类型 | 灰度策略 | 观察时间 | 回滚方式 |
|---------|---------|---------|---------|
| 普通功能 | 流量灰度 | 30分钟/阶段 | 流量切换 |
| 核心链路 | 流量+地域 | 1小时/阶段 | 流量切换 |
| 数据变更 | 商家灰度 | 2小时/阶段 | 数据补偿 |
| 大版本升级 | 全维度 | 1天/阶段 | 流量+数据 |

---

## 二、流量灰度实现

### 2.1 网关层流量分发

**灰度路由的核心思想**：在网关层根据用户ID的哈希值决定走哪个版本。为什么用用户ID而不是请求ID？因为要保证同一用户的体验一致——不能让用户一会儿看到新版本，一会儿看到旧版本。哈希保证了相同用户ID总是路由到同一版本。

**灰度比例的控制**：通过配置中心动态调整grayRatio，不需要重启服务。比如设置10，就是10%的用户走灰度版本。

```java
// 网关灰度路由配置
@Component
public class GrayRouter {

    // 灰度规则配置（从配置中心读取）
    @Value("${gray.ratio:0}")
    private int grayRatio;  // 灰度流量比例（0-100）

    @Value("${gray.version:v1}")
    private String grayVersion;  // 灰度版本标识

    public String route(HttpRequest request) {
        // 已标记的请求走固定版本
        String forceVersion = request.getHeader("X-Gray-Version");
        if (forceVersion != null) {
            return forceVersion;
        }

        // 按用户ID哈希决定是否走灰度
        Long userId = getUserId(request);
        int hash = Math.abs(userId.hashCode() % 100);

        if (hash < grayRatio) {
            return grayVersion;  // 走灰度版本
        } else {
            return "stable";     // 走稳定版本
        }
    }
}

// 流量分发
@Component
public class GrayLoadBalancer {

    public ServiceInstance choose(String serviceId, String version) {
        List<ServiceInstance> instances = discoveryClient.getInstances(serviceId);

        // 按版本筛选实例
        List<ServiceInstance> versionInstances = instances.stream()
            .filter(i -> version.equals(i.getMetadata().get("version")))
            .collect(Collectors.toList());

        if (versionInstances.isEmpty()) {
            // 没有对应版本，走默认
            return loadBalancer.choose(instances);
        }

        return loadBalancer.choose(versionInstances);
    }
}
```

### 2.2 灰度流程控制

**灰度控制API的设计**：提供start/adjust/rollback/complete四个接口，分别对应开始灰度、调整比例、回滚、全量发布。每个操作前都要检查当前状态和指标，不能盲目操作。比如adjust前要检查当前灰度指标是否正常，不正常就不建议扩大。

**回滚的关键**：只需要把灰度比例设为0，流量自然切回稳定版本，不需要重新部署，所以能做到秒级回滚。

```java
@RestController
@RequestMapping("/admin/gray")
public class GrayController {

    // 开始灰度
    @PostMapping("/start")
    public Result startGray(@RequestBody GrayConfig config) {
        // 1. 验证灰度配置
        validateConfig(config);

        // 2. 部署灰度版本（新版本打上灰度标签）
        deployService.deploy(config.getVersion(), "gray");

        // 3. 设置初始灰度比例（1%）
        grayConfigService.setRatio(1);

        // 4. 记录灰度开始
        grayLogService.log(config, "STARTED", "灰度开始，比例1%");

        return Result.success("灰度已开始");
    }

    // 调整灰度比例
    @PostMapping("/adjust")
    public Result adjustGray(@RequestParam int ratio) {
        // 检查当前灰度状态
        GrayStatus status = grayStatusService.getStatus();
        if (status != GrayStatus.IN_PROGRESS) {
            return Result.fail("当前没有进行中的灰度");
        }

        // 检查指标是否正常
        MetricsCheckResult checkResult = metricsChecker.check();
        if (!checkResult.isOk()) {
            return Result.fail("指标异常，不建议扩大灰度：" + checkResult.getMessage());
        }

        // 调整比例
        grayConfigService.setRatio(ratio);
        grayLogService.log(null, "ADJUSTED", "灰度比例调整为" + ratio + "%");

        return Result.success("灰度比例已调整为" + ratio + "%");
    }

    // 回滚
    @PostMapping("/rollback")
    public Result rollback() {
        // 1. 立即将灰度比例设为0
        grayConfigService.setRatio(0);

        // 2. 记录回滚
        grayLogService.log(null, "ROLLBACK", "灰度已回滚");

        return Result.success("已回滚，灰度流量已切回稳定版本");
    }

    // 全量发布
    @PostMapping("/complete")
    public Result complete() {
        // 1. 设置灰度比例为100%
        grayConfigService.setRatio(100);

        // 2. 等待所有流量切换
        Thread.sleep(10000);

        // 3. 将灰度版本标记为稳定版本
        deployService.markAsStable(grayConfigService.getVersion());

        // 4. 下线旧版本
        deployService.decommission("old_version");

        grayLogService.log(null, "COMPLETED", "灰度完成，已全量发布");

        return Result.success("全量发布完成");
    }
}
```

### 2.3 自动化灰度流程

**自动化灰度的价值**：减少人工操作，降低误操作风险。系统按预设的阶段（1%→5%→20%→50%→100%）自动推进，每个阶段观察30分钟，如果指标异常自动回滚。这样即使半夜发布也不需要人一直盯着。

**自动回滚的触发条件**：通过metricsChecker检查错误率、RT、业务指标等，任一异常就触发回滚。宁可误回滚，不可放过问题。

```java
// 自动灰度任务
@Component
public class AutoGrayProcessor {

    private static final int[] GRAY_STAGES = {1, 5, 20, 50, 100};
    private static final int OBSERVE_MINUTES = 30;

    public void executeAutoGray(String version) {
        for (int stage : GRAY_STAGES) {
            log.info("Starting gray stage: {}%", stage);

            // 调整灰度比例
            grayConfigService.setRatio(stage);

            // 观察期
            for (int i = 0; i < OBSERVE_MINUTES; i++) {
                Thread.sleep(60000);  // 每分钟检查一次

                // 检查指标
                MetricsCheckResult result = metricsChecker.check();
                if (!result.isOk()) {
                    log.error("Metrics check failed at stage {}%: {}",
                        stage, result.getMessage());

                    // 自动回滚
                    rollback();
                    alertService.send("灰度失败，已自动回滚：" + result.getMessage());
                    return;
                }
            }

            log.info("Gray stage {}% completed successfully", stage);
        }

        // 全部阶段完成
        complete();
        alertService.send("灰度发布完成：" + version);
    }
}
```

---

## 三、地域灰度

### 3.1 按SET灰度

```java
// SET级别的灰度配置
public class SetGrayConfig {

    // SET优先级（从低到高风险）
    private static final List<String> SET_PRIORITY = Arrays.asList(
        "test_set",      // 测试SET
        "xian_set",      // 西安（小流量城市）
        "chengdu_set",   // 成都
        "hangzhou_set",  // 杭州
        "guangzhou_set", // 广州
        "shanghai_set",  // 上海
        "beijing_set"    // 北京（最后）
    );

    // 当前灰度到哪个SET
    private int currentSetIndex = 0;

    public List<String> getGraySets() {
        return SET_PRIORITY.subList(0, currentSetIndex + 1);
    }

    public void nextSet() {
        if (currentSetIndex < SET_PRIORITY.size() - 1) {
            currentSetIndex++;
        }
    }
}

// SET路由
public String routeBySet(HttpRequest request) {
    String userCity = getUserCity(request);
    String targetSet = citySetMapping.get(userCity);

    if (grayConfig.getGraySets().contains(targetSet)) {
        return "gray";  // 该SET走灰度
    }
    return "stable";
}
```

### 3.2 地域灰度流程

```
地域灰度发布流程：

第1天：测试SET（内部测试）
    └─ 验证基本功能

第2天：西安SET（小城市）
    └─ 观察24小时，验证生产环境

第3天：成都、杭州SET（新一线城市）
    └─ 观察24小时

第4天：广州SET
    └─ 观察24小时

第5天：上海SET
    └─ 观察24小时

第6天：北京SET（最大流量）
    └─ 全量完成
```

---

## 四、商家灰度

### 4.1 商家分组

**商家灰度的价值**：不同商家的重要性不同。头部商家（VIP）贡献大量GMV，出问题影响严重；内部测试商家可以先试错；普通商家数量多，能验证规模问题。所以灰度顺序是：内部 → Beta → 普通 → VIP，从低风险到高风险。

**白名单和黑名单**：白名单用于指定某些商家必须走灰度（比如愿意配合测试的商家），黑名单用于保护某些商家不走灰度（比如正在搞大促的商家）。

```java
// 商家灰度分组
public enum MerchantGrayGroup {
    INTERNAL(1, "内部测试商家", 100),      // 公司内部商家
    BETA(2, "Beta商家", 1000),             // 愿意尝鲜的商家
    NORMAL(3, "普通商家", 1000000),        // 普通商家
    VIP(4, "头部商家", 50000);             // 头部大商家

    private int priority;      // 灰度优先级（越小越先）
    private String desc;
    private int count;         // 商家数量
}

// 商家灰度配置
public class MerchantGrayConfig {

    // 当前灰度的商家分组
    private Set<MerchantGrayGroup> grayGroups = new HashSet<>();

    // 白名单（强制走灰度）
    private Set<Long> whitelist = new HashSet<>();

    // 黑名单（强制不走灰度）
    private Set<Long> blacklist = new HashSet<>();

    public boolean isGray(Long merchantId) {
        if (blacklist.contains(merchantId)) {
            return false;
        }
        if (whitelist.contains(merchantId)) {
            return true;
        }

        MerchantGrayGroup group = getMerchantGroup(merchantId);
        return grayGroups.contains(group);
    }
}
```

### 4.2 商家灰度流程

```java
// 商家灰度控制
@RestController
@RequestMapping("/admin/merchantGray")
public class MerchantGrayController {

    // 开始商家灰度
    @PostMapping("/start")
    public Result start(@RequestBody MerchantGrayRequest request) {
        // 1. 先加入内部测试商家
        merchantGrayConfig.addGroup(MerchantGrayGroup.INTERNAL);

        // 2. 通知测试商家
        notifyMerchants(MerchantGrayGroup.INTERNAL, "新功能测试中，欢迎体验");

        return Result.success("已开始商家灰度，当前：内部测试商家");
    }

    // 扩展灰度范围
    @PostMapping("/expand")
    public Result expand(@RequestParam MerchantGrayGroup group) {
        // 检查是否可以扩展
        MetricsCheckResult checkResult = metricsChecker.checkByGroup(
            merchantGrayConfig.getGrayGroups());

        if (!checkResult.isOk()) {
            return Result.fail("当前灰度指标异常，不建议扩展：" + checkResult.getMessage());
        }

        // 扩展灰度范围
        merchantGrayConfig.addGroup(group);

        return Result.success("已扩展灰度范围：" + group.getDesc());
    }
}
```

---

## 五、回滚机制

### 5.1 回滚类型

```
回滚类型：

1. 流量回滚（最常用）
   - 将流量切回旧版本
   - 秒级生效
   - 不涉及数据修复

2. 代码回滚
   - 重新部署旧版本代码
   - 分钟级生效
   - 适用于流量切换不够的情况

3. 数据回滚
   - 修复或回滚数据变更
   - 可能需要小时级
   - 涉及数据补偿逻辑
```

### 5.2 快速流量回滚

**回滚速度是生命线**：故障时每多耽误一秒，都有更多用户受影响。流量回滚只需要修改配置（灰度比例设为0），网关立即生效，秒级完成。这比重新部署快10倍以上。

**回滚三步曲**：1）灰度比例归零；2）清空各维度灰度配置（SET、商家）；3）刷新网关路由缓存。顺序不能乱，否则可能有漏网之鱼。

```java
// 一键回滚
public class RollbackService {

    // 流量回滚（秒级）
    public void rollbackTraffic() {
        // 1. 将灰度比例设为0
        grayConfigService.setRatio(0);

        // 2. 清空灰度SET配置
        setGrayConfig.reset();

        // 3. 清空商家灰度配置
        merchantGrayConfig.reset();

        // 4. 刷新网关路由缓存
        gatewayService.refreshRoutes();

        log.info("Traffic rollback completed");
    }

    // 代码回滚
    public void rollbackCode(String targetVersion) {
        // 1. 先流量回滚
        rollbackTraffic();

        // 2. 下线灰度版本
        deployService.stop(grayConfigService.getVersion());

        // 3. 确保稳定版本实例数充足
        deployService.scale("stable", 100);

        log.info("Code rollback completed to version: {}", targetVersion);
    }
}
```

### 5.3 数据回滚

**数据回滚最复杂**：代码可以秒级回滚，但灰度期间产生的数据怎么办？比如新版本用新格式存储了数据，回滚后旧版本读不了。所以数据补偿任务要根据变更类型（INSERT/UPDATE/DELETE）分别处理。

**补偿策略**：
- INSERT的数据：评估是否需要删除（可能是正常业务数据，不应删除）
- UPDATE的数据：恢复旧值（从变更日志中读取）
- DELETE的数据：恢复（从变更日志中读取旧值重新插入）

```java
// 数据回滚/补偿
public class DataRollbackService {

    // 数据补偿任务
    public void compensate(String grayVersion, Date startTime, Date endTime) {
        log.info("Starting data compensation for version: {}", grayVersion);

        // 1. 查询灰度期间的数据变更
        List<DataChangeLog> changes = dataChangeLogDao.selectByTimeRange(
            grayVersion, startTime, endTime);

        // 2. 按变更类型分别处理
        for (DataChangeLog change : changes) {
            try {
                compensateChange(change);
            } catch (Exception e) {
                log.error("Compensate failed: {}", change.getId(), e);
                // 记录失败，人工处理
                compensateFailureDao.insert(change);
            }
        }

        log.info("Data compensation completed, total: {}", changes.size());
    }

    private void compensateChange(DataChangeLog change) {
        switch (change.getChangeType()) {
            case "INSERT":
                // 新增的数据，考虑是否需要删除
                if (shouldRollbackInsert(change)) {
                    productDao.deleteById(change.getProductId());
                }
                break;

            case "UPDATE":
                // 修改的数据，恢复旧值
                productDao.update(change.getProductId(), change.getOldValue());
                break;

            case "DELETE":
                // 删除的数据，恢复
                productDao.insert(change.getOldValue());
                break;
        }

        // 同步刷新缓存和ES
        dataRepairService.repairProduct(change.getProductId(),
            Sets.newHashSet("REDIS", "ES"));
    }
}
```

---

## 六、发布检查与卡点

### 6.1 发布前检查清单

**卡点的重要性**：很多线上事故是可以在发布前发现的，比如慢SQL、接口不兼容、配置错误。自动化检查在发布前拦截这些问题，比线上出了问题再回滚成本低得多。

**检查项说明**：
- 代码审查：确保有人Review过代码
- 单元测试：确保基本功能正常
- SQL审核：防止慢SQL上线
- 接口兼容性：防止破坏性变更
- 配置检查：确保配置完整正确

```java
// 发布前自动检查
public class PreReleaseChecker {

    public CheckResult check(ReleaseRequest request) {
        CheckResult result = new CheckResult();

        // 1. 代码审查检查
        if (!codeReviewPassed(request.getCommitId())) {
            result.addError("代码审查未通过");
        }

        // 2. 单元测试检查
        if (!unitTestPassed(request.getCommitId())) {
            result.addError("单元测试未通过");
        }

        // 3. SQL审核检查
        List<String> sqls = extractSqls(request.getCommitId());
        for (String sql : sqls) {
            SqlReviewResult sqlResult = sqlReviewer.review(sql);
            if (!sqlResult.isOk()) {
                result.addError("SQL审核未通过：" + sqlResult.getMessage());
            }
        }

        // 4. 接口兼容性检查
        ApiCompatResult apiResult = apiChecker.check(
            request.getOldVersion(), request.getNewVersion());
        if (!apiResult.isCompatible()) {
            result.addError("接口不兼容：" + apiResult.getMessage());
        }

        // 5. 配置检查
        ConfigCheckResult configResult = configChecker.check(request.getConfigs());
        if (!configResult.isOk()) {
            result.addError("配置检查失败：" + configResult.getMessage());
        }

        return result;
    }
}
```

### 6.2 SQL变更审核

**SQL审核的必要性**：数据库是系统瓶颈，一条慢SQL可以拖垮整个系统。自动化SQL审核可以发现：危险操作（DROP/TRUNCATE）、字段变更、缺少索引、缺少默认值等问题。

**审核规则示例**：
- 禁止DROP/TRUNCATE：这些操作不可逆，必须禁止
- 新增字段必须有默认值：否则可能导致历史数据不兼容
- 提供回滚SQL：出问题时能快速恢复

```java
// SQL变更审核规则
public class SqlReviewer {

    public SqlReviewResult review(String sql) {
        SqlReviewResult result = new SqlReviewResult();

        // 1. 禁止的操作
        if (sql.contains("DROP TABLE") || sql.contains("TRUNCATE")) {
            result.addError("禁止DROP/TRUNCATE操作");
        }

        // 2. 字段变更检查
        if (sql.contains("MODIFY COLUMN") || sql.contains("CHANGE COLUMN")) {
            result.addWarning("字段类型变更需要DBA审核");
        }

        // 3. 索引变更检查
        if (sql.contains("DROP INDEX")) {
            result.addWarning("删除索引需要确认影响");
        }

        // 4. 新增字段必须有默认值
        if (sql.contains("ADD COLUMN") && !sql.contains("DEFAULT")) {
            result.addError("新增字段必须有默认值");
        }

        // 5. 检查是否有对应的回滚SQL
        if (!hasRollbackSql(sql)) {
            result.addWarning("建议提供回滚SQL");
        }

        return result;
    }
}
```

### 6.3 接口兼容性检查

```java
// 接口兼容性检查
public class ApiCompatChecker {

    public ApiCompatResult check(String oldVersion, String newVersion) {
        ApiCompatResult result = new ApiCompatResult();

        // 获取新旧版本的接口定义
        List<ApiDefinition> oldApis = getApiDefinitions(oldVersion);
        List<ApiDefinition> newApis = getApiDefinitions(newVersion);

        // 检查删除的接口
        for (ApiDefinition oldApi : oldApis) {
            if (!existsInNewVersion(oldApi, newApis)) {
                result.addIncompatible("接口被删除：" + oldApi.getPath());
            }
        }

        // 检查修改的接口
        for (ApiDefinition oldApi : oldApis) {
            ApiDefinition newApi = findInNewVersion(oldApi, newApis);
            if (newApi != null) {
                // 检查请求参数变更
                checkRequestParamCompat(oldApi, newApi, result);
                // 检查响应字段变更
                checkResponseFieldCompat(oldApi, newApi, result);
            }
        }

        return result;
    }

    private void checkRequestParamCompat(ApiDefinition oldApi,
            ApiDefinition newApi, ApiCompatResult result) {
        // 新增必填参数 = 不兼容
        for (ParamDefinition newParam : newApi.getRequiredParams()) {
            if (!oldApi.hasParam(newParam.getName())) {
                result.addIncompatible(
                    oldApi.getPath() + " 新增必填参数：" + newParam.getName());
            }
        }
    }
}
```

---

## 七、灰度监控

### 7.1 灰度监控指标

```java
// 灰度监控指标
public class GrayMetrics {

    // 按版本统计的指标
    public void record(String version, String metric, double value) {
        Metrics.gauge(metric, Tags.of("version", version), value);
    }

    // 核心指标
    public void checkGrayHealth(String grayVersion) {
        String stableVersion = "stable";

        // 1. 错误率对比
        double grayErrorRate = getErrorRate(grayVersion);
        double stableErrorRate = getErrorRate(stableVersion);

        if (grayErrorRate > stableErrorRate * 1.5) {
            alertService.send("灰度版本错误率异常：" +
                grayErrorRate + " vs " + stableErrorRate);
        }

        // 2. RT对比
        double grayRt = getP99Rt(grayVersion);
        double stableRt = getP99Rt(stableVersion);

        if (grayRt > stableRt * 1.2) {
            alertService.send("灰度版本RT异常：" +
                grayRt + "ms vs " + stableRt + "ms");
        }

        // 3. 业务指标对比
        double grayConversion = getConversionRate(grayVersion);
        double stableConversion = getConversionRate(stableVersion);

        if (grayConversion < stableConversion * 0.95) {
            alertService.send("灰度版本转化率下降：" +
                grayConversion + " vs " + stableConversion);
        }
    }
}
```

### 7.2 灰度发布大盘

```
┌──────────────────────────────────────────────────────────┐
│                   灰度发布监控大盘                         │
├──────────────────────────────────────────────────────────┤
│ 当前灰度状态：进行中                                      │
│ 灰度版本：v2.3.1                                         │
│ 稳定版本：v2.3.0                                         │
│ 灰度比例：20%                                            │
│ 灰度开始时间：2024-01-15 10:00                           │
│                                                          │
│ 指标对比：                                                │
│ ┌──────────┬─────────┬─────────┬────────┐               │
│ │ 指标      │ 灰度版本 │ 稳定版本 │ 差异   │               │
│ ├──────────┼─────────┼─────────┼────────┤               │
│ │ 错误率    │ 0.05%   │ 0.04%   │ +25%   │ ⚠️            │
│ │ P99 RT   │ 48ms    │ 45ms    │ +6.7%  │ ✅            │
│ │ QPS      │ 20000   │ 80000   │ -      │ ✅            │
│ │ 转化率    │ 3.2%    │ 3.1%    │ +3.2%  │ ✅            │
│ └──────────┴─────────┴─────────┴────────┘               │
│                                                          │
│ 灰度进度：                                                │
│ [████████░░░░░░░░░░░░] 20%                               │
│                                                          │
│ 操作：[扩大灰度] [暂停] [回滚] [全量发布]                  │
└──────────────────────────────────────────────────────────┘
```

---

## 八、实战案例

### 8.1 案例：慢SQL导致灰度失败

**事故背景：**
- 新版本包含一个商品列表查询优化
- 灰度到20%时发现DB CPU飙升

**处理过程：**
```
10:00 - 开始灰度，比例1%
10:30 - 比例调整到5%，指标正常
11:00 - 比例调整到20%
11:05 - 告警：DB CPU使用率 > 80%
11:06 - 排查发现是新代码的SQL没走索引
11:08 - 执行回滚，流量切回稳定版本
11:10 - DB CPU恢复正常
```

**原因分析：**
```sql
-- 问题SQL
SELECT * FROM product
WHERE merchant_id = ? AND status = 1
ORDER BY update_time DESC
LIMIT 20;

-- 缺少复合索引，导致全表扫描
-- 在20%流量下暴露出性能问题
```

**改进措施：**
1. SQL变更必须经过DBA审核
2. 新增SQL审核自动化工具
3. 灰度期间增加DB监控权重

### 8.2 案例：数据兼容性问题

**事故背景：**
- 新版本修改了商品规格的存储格式
- JSON结构从`{specs: []}`改为`{specList: []}`
- 灰度期间新旧版本并存，数据格式不兼容

**问题现象：**
- 旧版本写入的数据，新版本读取报错
- 新版本写入的数据，旧版本读取报错

**解决方案：**
```java
// 兼容性处理：读取时同时支持两种格式
public List<ProductSpec> parseSpecs(String json) {
    JSONObject obj = JSON.parseObject(json);

    // 优先读取新格式
    if (obj.containsKey("specList")) {
        return obj.getJSONArray("specList").toJavaList(ProductSpec.class);
    }

    // 兼容旧格式
    if (obj.containsKey("specs")) {
        return obj.getJSONArray("specs").toJavaList(ProductSpec.class);
    }

    return Collections.emptyList();
}

// 写入时使用新格式，但保留旧字段（双写）
public String formatSpecs(List<ProductSpec> specs) {
    JSONObject obj = new JSONObject();
    obj.put("specList", specs);  // 新格式
    obj.put("specs", specs);     // 兼容旧版本
    return obj.toJSONString();
}
```

**分阶段发布计划：**
```
第1阶段（当前版本）：
- 读取：支持新旧两种格式
- 写入：双写（同时写两种格式）

第2阶段（全量发布后2周）：
- 确认所有服务都已升级
- 写入：只写新格式
- 读取：仍然支持两种格式

第3阶段（全量发布后1个月）：
- 数据迁移：将旧格式数据转换为新格式
- 读取：只支持新格式
```

---

## 九、最佳实践

### 9.1 灰度发布原则

```
1. 小步快跑
   - 每次灰度比例增加不超过2倍
   - 充分观察后再扩大

2. 可观测
   - 灰度指标必须和稳定版本对比
   - 异常要能快速发现

3. 可回滚
   - 任何时候都能快速回滚
   - 数据变更要有补偿方案

4. 兼容性优先
   - 新旧版本必须能共存
   - 不兼容的变更分多次发布
```

### 9.2 经验总结

```
常见问题：
1. 灰度比例太大 → 问题暴露时影响范围大
2. 观察时间太短 → 低频问题未暴露
3. 指标不全面 → 某些维度劣化未发现
4. 回滚速度慢 → 故障时间延长

建议：
1. 核心系统灰度周期不少于3天
2. 必须有自动化指标对比
3. 回滚能力要定期演练
4. 数据变更要格外谨慎
```
