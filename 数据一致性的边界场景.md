# 数据一致性的边界场景

## 核心要点（面试快速回答）

**Q: 下单过程中商品被下架了怎么办？**
分阶段处理：1）加购物车时不校验，允许加入；2）提交订单时校验，如果已下架则提示"商品已下架"并从购物车移除；3）支付时再次校验，如果状态变更则拦截支付。核心原则是"越晚发现成本越高"，所以关键节点都要校验。

**Q: 下单时价格变了怎么处理？**
订单会保存"下单时价格快照"。用户看到的价格和实际支付价格以快照为准，不会因为后台价格变更而变化。如果用户提交订单时价格已变（和购物车价格不一致），会提示"价格已变更"让用户确认。

**Q: 遇到过价格不一致的投诉吗？**
遇到过。主要是缓存延迟导致的：用户看到的是缓存价格（旧），下单时校验的是DB价格（新）。后来增加了"价格变更感知"：如果价格在用户浏览期间变更了，刷新页面时主动提示，而不是等到下单才发现。

**Q: 库存不一致怎么办？**
分两种情况：1）缓存库存和DB库存不一致——以DB为准，缓存只做展示，下单时查DB；2）实际库存和系统库存不一致——通过盘点机制修正，系统支持库存调整接口。

---

## 一、边界场景全景图

### 1.1 下单流程中的数据一致性风险点

```
用户操作流程：
浏览商品 → 加入购物车 → 提交订单 → 支付 → 完成

每个环节的风险：
┌──────────────┬─────────────────────────────────────┐
│ 环节         │ 可能发生的变更                        │
├──────────────┼─────────────────────────────────────┤
│ 浏览商品     │ 价格变更、库存变化、商品下架           │
├──────────────┼─────────────────────────────────────┤
│ 加入购物车   │ 价格变更、库存变化、商品下架、规格变更 │
├──────────────┼─────────────────────────────────────┤
│ 提交订单     │ 价格变更、库存不足、商品下架           │
├──────────────┼─────────────────────────────────────┤
│ 支付         │ 商品下架、库存被他人抢占               │
├──────────────┼─────────────────────────────────────┤
│ 配送中       │ 商品召回、商家停业                     │
└──────────────┴─────────────────────────────────────┘
```

### 1.2 一致性保障原则

```
核心原则：
1. 越早发现问题，处理成本越低
2. 关键数据以DB为准，缓存只做展示
3. 订单快照保存下单时的状态，不受后续变更影响
4. 涉及金额的校验必须严格
```

---

## 二、商品下架场景处理

### 2.1 商品下架的影响范围

```
商品被下架后的影响：

前台展示：
├─ 商品详情页：显示"商品已下架"
├─ 搜索结果：不再展示该商品
├─ 购物车：标记为"已失效"
└─ 商品列表：不再展示

交易链路：
├─ 新订单：不允许下单
├─ 已创建未支付订单：需要特殊处理
└─ 已支付订单：正常履约（已锁定）
```

### 2.2 各环节的处理策略

**浏览商品时下架：**

**处理思路**：用户浏览时发现商品已下架，不能简单返回错误，而是要给用户一个友好的提示，并推荐类似商品，减少用户流失。这体现了"异常情况也要考虑用户体验"的设计原则。

```java
public ProductDetailVO getProductDetail(Long productId) {
    Product product = productService.getById(productId);

    if (product == null) {
        throw new BusinessException("商品不存在");
    }

    if (product.getStatus() == ProductStatus.OFF_SHELF) {
        // 商品已下架，返回下架提示
        ProductDetailVO vo = new ProductDetailVO();
        vo.setProductId(productId);
        vo.setStatus("OFF_SHELF");
        vo.setMessage("抱歉，该商品已下架");
        vo.setRecommendProducts(getRecommendProducts(product));  // 推荐类似商品
        return vo;
    }

    return buildProductDetail(product);
}
```

**加购物车时下架：**

**处理思路**：加购物车时采用"宽松校验"策略。原因是用户可能正在浏览页面，商品状态随时可能变化，如果严格校验会导致频繁失败。真正的严格校验放在提交订单时，这是"渐进式校验"的思想——越接近交易完成，校验越严格。

```java
public Result addToCart(Long productId, Integer quantity) {
    Product product = productService.getById(productId);

    // 加购物车时不强校验状态，允许加入
    // 原因：用户可能正在浏览，商品状态随时可能变
    // 真正校验在提交订单时

    CartItem item = new CartItem();
    item.setProductId(productId);
    item.setProductName(product.getName());
    item.setPrice(product.getPrice());
    item.setQuantity(quantity);
    item.setStatus(product.getStatus());  // 记录当时的状态

    cartService.add(item);

    // 如果商品已下架，返回提示但不阻止
    if (product.getStatus() == ProductStatus.OFF_SHELF) {
        return Result.success().withWarning("该商品已下架，可能无法购买");
    }

    return Result.success();
}
```

**提交订单时下架：**

**处理思路**：提交订单是关键节点，必须严格校验。如果发现商品已下架，不仅要拦截订单，还要主动帮用户清理购物车中的失效商品，避免用户下次还看到这些商品。这个设计体现了"主动帮用户解决问题"的理念。

```java
public Result submitOrder(OrderSubmitRequest request) {
    List<CartItem> items = request.getItems();
    List<String> invalidItems = new ArrayList<>();

    for (CartItem item : items) {
        Product product = productService.getById(item.getProductId());

        // 严格校验商品状态
        if (product == null || product.getStatus() == ProductStatus.OFF_SHELF) {
            invalidItems.add(item.getProductName());
            // 从购物车移除失效商品
            cartService.remove(item.getProductId());
        }
    }

    if (!invalidItems.isEmpty()) {
        return Result.fail("以下商品已下架，请重新选择：" + String.join("、", invalidItems));
    }

    // 继续创建订单...
    return createOrder(request);
}
```

**支付时下架：**

**处理思路**：支付前的二次校验是最后一道防线。虽然提交订单时已经校验过，但在用户支付前这段时间，商品状态可能发生变化（比如商家临时下架）。这里我们选择"策略2：拦截支付"，因为如果商品已下架，商家可能无法提供服务，强行完成支付会导致后续更多问题。

```java
public Result pay(Long orderId) {
    Order order = orderService.getById(orderId);

    // 支付前再次校验商品状态
    for (OrderItem item : order.getItems()) {
        Product product = productService.getById(item.getProductId());

        if (product.getStatus() == ProductStatus.OFF_SHELF) {
            // 商品在下单后被下架
            // 策略1：允许支付（商家已接单的情况）
            // 策略2：拦截支付（商品确实无法提供）

            // 我们采用策略2，拦截支付
            order.setStatus(OrderStatus.CANCELLED);
            order.setCancelReason("商品已下架");
            orderService.update(order);

            return Result.fail("抱歉，商品已下架，订单已取消");
        }
    }

    // 继续支付流程...
    return processPayment(order);
}
```

### 2.3 购物车的失效商品处理

**设计要点**：购物车页面需要同时展示有效商品和失效商品，但要区分开来。失效商品不参与价格计算，但保留展示可以让用户知道"为什么我的购物车里少了东西"。这种透明化的设计比直接删除更友好。

```java
// 购物车页面加载时，检查商品状态
public CartVO getCart(Long userId) {
    List<CartItem> items = cartService.getByUserId(userId);
    CartVO vo = new CartVO();

    List<CartItemVO> validItems = new ArrayList<>();
    List<CartItemVO> invalidItems = new ArrayList<>();

    for (CartItem item : items) {
        Product product = productService.getById(item.getProductId());
        CartItemVO itemVO = buildCartItemVO(item, product);

        if (product == null || product.getStatus() == ProductStatus.OFF_SHELF) {
            itemVO.setInvalid(true);
            itemVO.setInvalidReason("商品已下架");
            invalidItems.add(itemVO);
        } else if (product.getStock() < item.getQuantity()) {
            itemVO.setInvalid(true);
            itemVO.setInvalidReason("库存不足");
            invalidItems.add(itemVO);
        } else {
            validItems.add(itemVO);
        }
    }

    vo.setValidItems(validItems);
    vo.setInvalidItems(invalidItems);  // 失效商品单独展示
    vo.setTotalPrice(calculateTotalPrice(validItems));

    return vo;
}
```

---

## 三、价格变更场景处理

### 3.1 价格变更的影响

```
价格变更时间线：
商品页面加载（价格A）→ 加入购物车 → 后台修改价格（价格B）→ 提交订单

问题：用户看到的是价格A，实际应该付价格B？

我们的策略：
- 购物车：显示最新价格，如有变化标注"价格已变"
- 下单：以提交订单时的价格为准，生成订单快照
- 支付：以订单快照价格为准，不受后续变更影响
```

### 3.2 价格快照机制

**核心思想**：订单一旦创建，就是一个"快照"，不受后续商品信息变化的影响。这解决了"用户下单后商品涨价，该收多少钱"的问题。答案是：收下单时的价格。快照机制保证了交易的确定性，用户看到什么价格下单，就付什么价格。

**关键实现点**：
1. 订单商品表中保存的是下单时的价格，不是商品ID的引用
2. 商品信息也保存快照（JSON格式），用于订单详情展示
3. 这样即使商品被删除，订单历史依然完整

```java
// 创建订单时保存价格快照
public Order createOrder(OrderSubmitRequest request) {
    Order order = new Order();
    order.setOrderId(generateOrderId());
    order.setUserId(request.getUserId());
    order.setCreateTime(new Date());

    List<OrderItem> orderItems = new ArrayList<>();
    BigDecimal totalPrice = BigDecimal.ZERO;

    for (CartItem cartItem : request.getItems()) {
        Product product = productService.getById(cartItem.getProductId());

        OrderItem orderItem = new OrderItem();
        orderItem.setProductId(product.getId());
        orderItem.setProductName(product.getName());

        // 关键：保存下单时的价格快照
        orderItem.setPrice(product.getPrice());
        orderItem.setOriginalPrice(product.getOriginalPrice());
        orderItem.setQuantity(cartItem.getQuantity());

        // 保存商品快照（防止商品信息变更）
        orderItem.setProductSnapshot(JSON.toJSONString(product));

        orderItems.add(orderItem);
        totalPrice = totalPrice.add(product.getPrice().multiply(
            new BigDecimal(cartItem.getQuantity())));
    }

    order.setItems(orderItems);
    order.setTotalPrice(totalPrice);

    orderDao.insert(order);
    return order;
}
```

### 3.3 价格变更感知与提示

**购物车价格变更提示：**
```java
public CartVO getCart(Long userId) {
    List<CartItem> items = cartService.getByUserId(userId);

    for (CartItem item : items) {
        Product product = productService.getById(item.getProductId());

        // 比较购物车中的价格和当前价格
        if (!item.getPrice().equals(product.getPrice())) {
            item.setPriceChanged(true);
            item.setOldPrice(item.getPrice());
            item.setNewPrice(product.getPrice());

            // 更新购物车中的价格
            item.setPrice(product.getPrice());
            cartService.update(item);
        }
    }

    return buildCartVO(items);
}
```

**提交订单时的价格校验：**
```java
public Result submitOrder(OrderSubmitRequest request) {
    List<PriceChangeInfo> priceChanges = new ArrayList<>();

    for (CartItem item : request.getItems()) {
        Product product = productService.getById(item.getProductId());

        // 比较用户提交的价格和当前DB价格
        if (!item.getPrice().equals(product.getPrice())) {
            PriceChangeInfo change = new PriceChangeInfo();
            change.setProductName(product.getName());
            change.setOldPrice(item.getPrice());
            change.setNewPrice(product.getPrice());
            priceChanges.add(change);
        }
    }

    if (!priceChanges.isEmpty()) {
        // 价格有变化，返回给前端确认
        return Result.needConfirm("以下商品价格已变更，是否继续下单？")
            .withData(priceChanges);
    }

    // 价格无变化，正常下单
    return createOrder(request);
}
```

### 3.4 价格校验的边界处理

**营销价格与原价的处理：**
```java
public class PriceCalculator {

    public BigDecimal calculateFinalPrice(Product product, Long userId) {
        BigDecimal basePrice = product.getPrice();

        // 1. 检查限时折扣
        Promotion promotion = promotionService.getActivePromotion(product.getId());
        if (promotion != null) {
            basePrice = promotion.getPromotionPrice();
        }

        // 2. 检查会员价
        User user = userService.getById(userId);
        if (user.isVip() && product.getVipPrice() != null) {
            basePrice = basePrice.min(product.getVipPrice());
        }

        // 3. 检查优惠券（在订单层面计算，不在这里）

        return basePrice;
    }
}
```

---

## 四、库存不一致场景处理

### 4.1 库存一致性的挑战

```
库存数据存在于多个地方：
1. 数据库（真实库存）
2. Redis缓存（展示库存）
3. 本地缓存（展示库存）
4. ES搜索引擎（筛选条件）

不一致场景：
- 缓存未及时更新，显示有库存但实际没有
- 并发扣减，超卖
- 系统库存和实际库存不符
```

### 4.2 库存展示与校验分离

**设计原则**："展示用缓存（容忍不精确），交易用DB（必须精确）"。这是一个重要的取舍：如果展示也查DB，系统扛不住；如果交易也用缓存，可能超卖。所以我们接受列表页库存可能有几秒延迟，但下单时一定查实时库存。

```java
// 商品列表/详情页：展示缓存库存（允许不准确）
public ProductVO getProductForDisplay(Long productId) {
    ProductVO vo = new ProductVO();

    // 从缓存获取库存（可能不是最新）
    Integer cachedStock = stockCache.get(productId);
    vo.setStock(cachedStock);
    vo.setInStock(cachedStock > 0);

    return vo;
}

// 下单时：校验DB库存（必须准确）
public Result submitOrder(OrderSubmitRequest request) {
    for (CartItem item : request.getItems()) {
        // 从DB获取实时库存
        Integer dbStock = stockService.getStockFromDB(item.getProductId());

        if (dbStock < item.getQuantity()) {
            return Result.fail(item.getProductName() + " 库存不足，仅剩 " + dbStock + " 件");
        }
    }

    // 库存充足，继续下单
    return createOrder(request);
}
```

### 4.3 库存扣减的原子性

**防超卖的关键**：使用数据库的乐观锁机制，在SQL层面保证原子性。核心技巧是在UPDATE语句的WHERE条件中加入"quantity >= #{quantity}"，这样只有库存足够时才会扣减成功，否则affected rows为0。这比先SELECT再UPDATE安全得多，因为后者在并发时可能出现"检查时够，扣减时不够"的情况。

```java
// 使用乐观锁扣减库存，防止超卖
public boolean deductStock(Long productId, Integer quantity) {
    // 乐观锁：只有库存足够时才扣减
    int affected = stockDao.deduct(productId, quantity);

    // SQL: UPDATE stock SET quantity = quantity - #{quantity}
    //      WHERE product_id = #{productId} AND quantity >= #{quantity}

    if (affected == 0) {
        // 库存不足
        return false;
    }

    // 扣减成功，异步更新缓存
    asyncRefreshStockCache(productId);

    return true;
}
```

### 4.4 库存回滚机制

```java
// 订单取消时回滚库存
public void cancelOrder(Long orderId, String reason) {
    Order order = orderDao.selectById(orderId);

    // 1. 更新订单状态
    order.setStatus(OrderStatus.CANCELLED);
    order.setCancelReason(reason);
    orderDao.update(order);

    // 2. 回滚库存
    for (OrderItem item : order.getItems()) {
        stockService.increaseStock(item.getProductId(), item.getQuantity());
    }

    // 3. 记录库存变更日志
    stockLogService.log(orderId, "ROLLBACK", order.getItems());
}
```

---

## 五、并发场景的一致性

### 5.1 并发下单的处理

**并发控制三件套**：分布式锁+幂等检查+异常处理。分布式锁防止同一用户并发下单（比如双击按钮）；幂等检查防止重复提交（比如网络重试）；异常时确保释放锁（finally块）。这三者缺一不可，否则都可能导致问题。

```java
// 使用分布式锁防止并发问题
public Result submitOrder(OrderSubmitRequest request) {
    String lockKey = "order:submit:" + request.getUserId();

    // 获取分布式锁，防止同一用户并发下单
    boolean locked = redisLock.tryLock(lockKey, 10, TimeUnit.SECONDS);
    if (!locked) {
        return Result.fail("订单提交中，请勿重复操作");
    }

    try {
        // 幂等性检查
        String requestId = request.getRequestId();
        if (isProcessed(requestId)) {
            return Result.fail("请勿重复提交");
        }

        // 正常下单流程
        Order order = createOrder(request);

        // 标记请求已处理
        markAsProcessed(requestId, order.getOrderId());

        return Result.success(order);

    } finally {
        redisLock.unlock(lockKey);
    }
}
```

### 5.2 秒杀场景的一致性

**秒杀的特殊性**：流量集中、库存有限、响应要快。常规的"先创建订单再扣库存"在秒杀场景下会把DB打爆。所以秒杀采用"先扣库存再创建订单"的策略，并且库存扣减用Redis原子操作（decrement），订单创建异步处理（MQ）。这样能把峰值QPS扛在Redis层面，DB只需要处理MQ消费速度的订单创建。

**注意异常处理**：如果Redis扣减成功但后续处理失败，必须恢复库存（increment），否则会出现"库存扣了但没订单"的情况。

```java
// 秒杀场景：先扣库存，再创建订单
public Result seckill(Long productId, Long userId) {
    // 1. 使用Redis原子操作扣减库存
    Long remainStock = redisTemplate.opsForValue()
        .decrement("seckill:stock:" + productId);

    if (remainStock < 0) {
        // 库存不足，恢复
        redisTemplate.opsForValue().increment("seckill:stock:" + productId);
        return Result.fail("手慢了，商品已抢完");
    }

    try {
        // 2. 创建订单（异步处理，避免阻塞）
        SeckillOrder order = new SeckillOrder();
        order.setProductId(productId);
        order.setUserId(userId);
        order.setStatus(SeckillOrderStatus.PENDING);

        // 发送到MQ，异步创建订单
        mqProducer.send("seckill_order_topic", JSON.toJSONString(order));

        return Result.success("秒杀成功，订单处理中");

    } catch (Exception e) {
        // 异常时恢复库存
        redisTemplate.opsForValue().increment("seckill:stock:" + productId);
        return Result.fail("系统繁忙，请重试");
    }
}
```

---

## 六、实际投诉案例与处理

### 6.1 案例1：价格不一致投诉

**用户投诉：**
"我看到商品是9.9元，下单后变成了12.9元"

**排查过程：**
```
1. 查看用户下单时间：14:32:15
2. 查看价格变更记录：14:30:00 从9.9改为12.9
3. 查看缓存刷新时间：14:33:00

结论：
- 用户14:30前看到的是缓存价格9.9
- 商家14:30修改为12.9
- 用户14:32下单时，缓存还未刷新，但DB已是12.9
- 提交订单时校验的是DB价格12.9
```

**解决方案：**
```java
// 优化1：提交订单前主动刷新价格
public Result submitOrder(OrderSubmitRequest request) {
    // 强制刷新商品信息
    for (CartItem item : request.getItems()) {
        Product freshProduct = productService.getFromDB(item.getProductId());

        if (!item.getPrice().equals(freshProduct.getPrice())) {
            // 价格有变化，中断并提示
            return Result.needConfirm("商品价格有变化，请确认后再下单");
        }
    }
    // ...
}

// 优化2：商品详情页增加价格变更实时推送
// 使用WebSocket推送价格变更通知
```

### 6.2 案例2：库存不一致投诉

**用户投诉：**
"显示有库存，但下单说库存不足"

**排查过程：**
```
1. 查看用户浏览时间：14:20:00，缓存库存：5
2. 查看其他订单：14:20-14:25有10个订单扣完了库存
3. 用户下单时间：14:26:00，DB库存：0

结论：
- 缓存库存更新延迟（设置的是5分钟TTL）
- 在用户浏览和下单之间，库存被其他人买完了
```

**解决方案：**
```java
// 优化1：热门商品的库存缓存TTL缩短到30秒
public void cacheStock(Long productId, Integer stock) {
    int ttl = isHotProduct(productId) ? 30 : 300;  // 热门商品30秒，普通5分钟
    redisTemplate.opsForValue().set("stock:" + productId, stock, ttl, TimeUnit.SECONDS);
}

// 优化2：库存变化时主动刷新缓存
@CanalEventListener(table = "stock")
public void onStockChange(CanalEntry entry) {
    Long productId = getProductId(entry);
    Integer newStock = getNewStock(entry);
    redisTemplate.opsForValue().set("stock:" + productId, newStock);
}

// 优化3：低库存时展示"库存紧张"提示
public ProductVO getProduct(Long productId) {
    ProductVO vo = buildProductVO(productId);

    if (vo.getStock() > 0 && vo.getStock() < 10) {
        vo.setStockWarning("库存紧张，欲购从速");
    }

    return vo;
}
```

---

## 七、一致性保障的监控

### 7.1 监控指标

```
价格一致性监控：
- 价格变更后缓存刷新延迟（目标<5秒）
- 下单时价格校验失败率（目标<0.1%）
- 价格不一致投诉数（目标<10/天）

库存一致性监控：
- 缓存库存与DB库存差异率（目标<1%）
- 超卖次数（目标：0）
- 库存不足导致的下单失败率（目标<1%）

商品状态一致性监控：
- 下架商品被下单次数（目标：0）
- 购物车失效商品占比
- 状态同步延迟（目标<3秒）
```

### 7.2 对账机制

```java
// 每小时对账：比对缓存和DB的价格
@Scheduled(cron = "0 0 * * * ?")
public void reconcilePrice() {
    // 随机抽取1万个商品
    List<Long> sampleIds = productService.randomSample(10000);

    int inconsistentCount = 0;
    for (Long productId : sampleIds) {
        BigDecimal cachePrice = priceCache.get(productId);
        BigDecimal dbPrice = productService.getPriceFromDB(productId);

        if (!Objects.equals(cachePrice, dbPrice)) {
            inconsistentCount++;
            // 修复缓存
            priceCache.refresh(productId);
            log.warn("Price inconsistent: productId={}, cache={}, db={}",
                productId, cachePrice, dbPrice);
        }
    }

    // 上报监控
    metrics.gauge("price.inconsistent.rate", inconsistentCount / 10000.0);

    if (inconsistentCount > 100) {
        alertService.send("价格一致性异常，不一致数量：" + inconsistentCount);
    }
}
```

---

## 八、最佳实践

### 8.1 设计原则

```
1. 关键校验放在DB层
   - 展示用缓存（容忍延迟）
   - 交易用DB（必须准确）

2. 快照保护已创建的订单
   - 订单创建后，不受商品后续变更影响
   - 价格、商品信息都保存快照

3. 分阶段校验
   - 加购物车：宽松校验，只做提示
   - 提交订单：严格校验，拦截异常
   - 支付：二次校验，防止漏网

4. 用户友好的错误处理
   - 明确告知问题原因
   - 提供替代方案（推荐类似商品）
   - 自动清理失效数据
```

### 8.2 经验教训

```
教训1：缓存延迟导致体验问题
- 现象：价格变更后用户还能看到旧价格
- 解决：关键数据缓存TTL缩短 + 主动刷新

教训2：并发场景考虑不足
- 现象：秒杀场景超卖
- 解决：Redis原子操作 + 数据库乐观锁双重保障

教训3：错误提示不友好
- 现象：用户看到"系统错误"
- 解决：细化错误码，给出明确提示和建议
```
