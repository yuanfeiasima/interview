# 限流算法面试题汇总

## 一、基础概念类

### 1. 解释漏桶和令牌桶算法的工作原理

**漏桶算法（Leaky Bucket）：**
- 请求以任意速率进入桶中
- 桶以固定速率流出请求进行处理
- 桶有固定容量，满了则溢出（拒绝新请求）
- 特点：强制固定速率输出，平滑流量

**令牌桶算法（Token Bucket）：**
- 系统以固定速率向桶中添加令牌
- 请求到来时需要消耗令牌才能通过
- 桶有最大容量，令牌满了则丢弃新令牌
- 特点：允许突发流量，只要有足够令牌

### 2. 漏桶和令牌桶的核心区别是什么？

| 维度 | 漏桶算法 | 令牌桶算法 |
|------|---------|-----------|
| 流量控制 | 强制固定速率输出 | 允许突发流量 |
| 处理方式 | 请求排队，匀速处理 | 有令牌立即处理 |
| 突发处理 | 不支持突发 | 支持突发（桶容量内） |
| 应用场景 | 网络流量整形 | API限流 |

### 3. 各自的应用场景

**漏桶算法适用场景：**
- 需要严格控制流量速率的场景
- 网络流量整形（Traffic Shaping）
- 保护后端服务不被突发流量冲垮
- 需要平滑流量的场景

**令牌桶算法适用场景：**
- API接口限流
- 允许短时突发的业务场景
- 需要灵活控制流量的场景
- 大多数互联网应用的限流需求

## 二、实现类

### 4. 手写实现令牌桶算法

```java
public class TokenBucket {
    private final long capacity;        // 桶容量
    private final long refillRate;      // 令牌生成速率（每秒）
    private long tokens;                // 当前令牌数
    private long lastRefillTime;        // 上次填充时间
    
    public TokenBucket(long capacity, long refillRate) {
        this.capacity = capacity;
        this.refillRate = refillRate;
        this.tokens = capacity;
        this.lastRefillTime = System.currentTimeMillis();
    }
    
    public synchronized boolean tryConsume(long tokensRequired) {
        refill();
        
        if (tokens >= tokensRequired) {
            tokens -= tokensRequired;
            return true;
        }
        return false;
    }
    
    private void refill() {
        long now = System.currentTimeMillis();
        long elapsedTime = now - lastRefillTime;
        long tokensToAdd = (elapsedTime * refillRate) / 1000;
        
        if (tokensToAdd > 0) {
            tokens = Math.min(capacity, tokens + tokensToAdd);
            lastRefillTime = now;
        }
    }
}
```

### 5. 手写实现漏桶算法

```java
public class LeakyBucket {
    private final long capacity;        // 桶容量
    private final long leakRate;        // 漏出速率（每秒）
    private long water;                 // 当前水量
    private long lastLeakTime;          // 上次漏水时间
    
    public LeakyBucket(long capacity, long leakRate) {
        this.capacity = capacity;
        this.leakRate = leakRate;
        this.water = 0;
        this.lastLeakTime = System.currentTimeMillis();
    }
    
    public synchronized boolean tryConsume() {
        leak();
        
        if (water < capacity) {
            water++;
            return true;
        }
        return false;
    }
    
    private void leak() {
        long now = System.currentTimeMillis();
        long elapsedTime = now - lastLeakTime;
        long leaked = (elapsedTime * leakRate) / 1000;
        
        if (leaked > 0) {
            water = Math.max(0, water - leaked);
            lastLeakTime = now;
        }
    }
}
```

### 6. 如何实现分布式限流？

**方案一：Redis + Lua脚本**

```lua
-- 令牌桶 Lua 脚本
local key = KEYS[1]
local capacity = tonumber(ARGV[1])
local rate = tonumber(ARGV[2])
local requested = tonumber(ARGV[3])
local now = tonumber(ARGV[4])

local bucket = redis.call('HMGET', key, 'tokens', 'last_time')
local tokens = tonumber(bucket[1]) or capacity
local last_time = tonumber(bucket[2]) or now

-- 计算新增令牌
local delta = math.max(0, now - last_time)
local new_tokens = math.min(capacity, tokens + delta * rate)

-- 尝试消费
if new_tokens >= requested then
    new_tokens = new_tokens - requested
    redis.call('HMSET', key, 'tokens', new_tokens, 'last_time', now)
    redis.call('EXPIRE', key, 3600)
    return 1
else
    return 0
end
```

**方案二：滑动窗口算法**

```java
public class RedisRateLimiter {
    private final RedisTemplate<String, String> redisTemplate;
    
    public boolean tryAcquire(String key, int limit, int windowSize) {
        long now = System.currentTimeMillis();
        long windowStart = now - windowSize * 1000;
        
        // 移除窗口外的记录
        redisTemplate.opsForZSet().removeRangeByScore(key, 0, windowStart);
        
        // 统计当前窗口内的请求数
        Long count = redisTemplate.opsForZSet().zCard(key);
        
        if (count < limit) {
            redisTemplate.opsForZSet().add(key, String.valueOf(now), now);
            redisTemplate.expire(key, windowSize, TimeUnit.SECONDS);
            return true;
        }
        return false;
    }
}
```

**需要考虑的问题：**
- 时钟同步问题（使用Redis时间戳）
- 网络延迟
- Redis单点故障（主从、集群）
- 性能优化（Pipeline、批量操作）

## 三、进阶类

### 7. 令牌桶如何处理突发流量？

**桶容量设计：**
- 桶容量 = 平均速率 × 允许突发时长
- 例如：100 QPS，允许2秒突发，桶容量 = 200

**预热机制（Warm-up）：**
```java
public class WarmUpTokenBucket {
    private long warmupPeriod;  // 预热时长
    private long startTime;
    
    public long getCurrentRate() {
        long elapsed = System.currentTimeMillis() - startTime;
        if (elapsed < warmupPeriod) {
            // 线性增长到目标速率
            return minRate + (maxRate - minRate) * elapsed / warmupPeriod;
        }
        return maxRate;
    }
}
```

### 8. 两种算法的时间复杂度和空间复杂度

**令牌桶算法：**
- 时间复杂度：O(1) - 每次请求只需计算令牌数
- 空间复杂度：O(1) - 只需存储固定变量

**漏桶算法：**
- 时间复杂度：O(1) - 每次请求只需更新水量
- 空间复杂度：O(1) 或 O(n) - 取决于是否使用队列实现

### 9. 在高并发场景下如何优化？

**无锁实现（CAS）：**
```java
public class LockFreeTokenBucket {
    private final AtomicLong tokens;
    private final AtomicLong lastRefillTime;
    
    public boolean tryConsume(long required) {
        while (true) {
            long current = tokens.get();
            refill();
            long updated = tokens.get();
            
            if (updated >= required) {
                if (tokens.compareAndSet(updated, updated - required)) {
                    return true;
                }
            } else {
                return false;
            }
        }
    }
}
```

**本地缓存 + 远程限流结合：**
- 本地限流器快速拒绝明显超限请求
- 远程限流器保证全局准确性
- 定期同步配额

**分段限流：**
- 将流量分散到多个桶
- 减少锁竞争
- 提高并发性能

### 10. 如果限流失败，有哪些降级策略？

**快速失败（Fail Fast）：**
- 立即返回错误（HTTP 429）
- 适用于非关键业务

**排队等待（Queue）：**
- 将请求放入队列
- 设置超时时间
- 适用于可以延迟处理的场景

**降级服务（Degradation）：**
- 返回缓存数据
- 返回默认值
- 提供简化版服务

**弹性扩容：**
- 自动扩容服务实例
- 动态调整限流阈值

## 四、其他常见限流算法

### 14. 除了漏桶、令牌桶、滑动窗口，还有哪些常见限流算法？

#### 1. 固定窗口计数器（Fixed Window Counter）

**原理：**
- 将时间划分为固定窗口（如1秒）
- 统计每个窗口内的请求数
- 超过阈值则拒绝
- 窗口结束时计数器重置

**实现：**
```java
public class FixedWindowCounter {
    private final int limit;
    private final long windowSize;  // 毫秒
    private AtomicInteger counter = new AtomicInteger(0);
    private long windowStart;
    
    public FixedWindowCounter(int limit, long windowSize) {
        this.limit = limit;
        this.windowSize = windowSize;
        this.windowStart = System.currentTimeMillis();
    }
    
    public synchronized boolean tryAcquire() {
        long now = System.currentTimeMillis();
        
        // 检查是否需要重置窗口
        if (now - windowStart >= windowSize) {
            counter.set(0);
            windowStart = now;
        }
        
        if (counter.get() < limit) {
            counter.incrementAndGet();
            return true;
        }
        return false;
    }
}
```

**优点：**
- 实现简单
- 内存占用小
- 性能高

**缺点：**
- **窗口边界问题**：在窗口切换时刻可能出现瞬时流量是限制的2倍
- 例如：限制100 QPS，在第1秒的后500ms来了100个请求，第2秒的前500ms又来了100个请求，实际1秒内处理了200个请求

#### 2. 滑动日志算法（Sliding Log）

**原理：**
- 记录每个请求的时间戳到日志中
- 请求到来时，清理过期的时间戳
- 统计时间窗口内的请求数

**实现：**
```java
public class SlidingLogRateLimiter {
    private final int limit;
    private final long windowSize;  // 毫秒
    private final Queue<Long> requestLog = new LinkedList<>();
    
    public SlidingLogRateLimiter(int limit, long windowSize) {
        this.limit = limit;
        this.windowSize = windowSize;
    }
    
    public synchronized boolean tryAcquire() {
        long now = System.currentTimeMillis();
        long boundary = now - windowSize;
        
        // 移除过期的请求记录
        while (!requestLog.isEmpty() && requestLog.peek() <= boundary) {
            requestLog.poll();
        }
        
        if (requestLog.size() < limit) {
            requestLog.offer(now);
            return true;
        }
        return false;
    }
}
```

**优点：**
- 精确控制，无窗口边界问题
- 可以精确统计任意时间窗口内的请求

**缺点：**
- 内存占用大（需要存储每个请求的时间戳）
- 性能相对较低（需要遍历清理过期记录）
- 不适合高并发场景

#### 3. 计数器算法（Simple Counter）

**原理：**
- 最简单的限流方式
- 固定时间段内计数
- 到达阈值后拒绝请求
- 时间段结束后重置

**实现：**
```java
public class SimpleCounter {
    private AtomicInteger count = new AtomicInteger(0);
    private final int maxCount;
    
    public SimpleCounter(int maxCount) {
        this.maxCount = maxCount;
    }
    
    public boolean tryAcquire() {
        return count.incrementAndGet() <= maxCount;
    }
    
    public void reset() {
        count.set(0);
    }
}
```

**优点：**
- 实现极其简单
- 性能最高

**缺点：**
- 不够平滑
- 需要外部定时重置
- 有窗口边界问题

#### 4. 自适应限流（Adaptive Rate Limiting）

**原理：**
- 根据系统负载动态调整限流阈值
- 监控CPU、内存、响应时间等指标
- 系统压力大时收紧限流，压力小时放宽

**实现思路：**
```java
public class AdaptiveRateLimiter {
    private volatile int currentLimit;
    private final int minLimit;
    private final int maxLimit;
    
    public AdaptiveRateLimiter(int minLimit, int maxLimit) {
        this.minLimit = minLimit;
        this.maxLimit = maxLimit;
        this.currentLimit = maxLimit;
    }
    
    public void adjustLimit() {
        double cpuUsage = getCpuUsage();
        double avgResponseTime = getAvgResponseTime();
        
        if (cpuUsage > 0.8 || avgResponseTime > 1000) {
            // 系统压力大，降低限流阈值
            currentLimit = Math.max(minLimit, (int)(currentLimit * 0.9));
        } else if (cpuUsage < 0.5 && avgResponseTime < 500) {
            // 系统压力小，提高限流阈值
            currentLimit = Math.min(maxLimit, (int)(currentLimit * 1.1));
        }
    }
    
    public boolean tryAcquire() {
        // 使用当前动态阈值进行限流
        return rateLimiter.tryAcquire(currentLimit);
    }
}
```

**应用场景：**
- Sentinel 的自适应限流
- 根据系统容量自动调节
- 防止系统过载

#### 5. 并发数限流（Concurrency Limiter）

**原理：**
- 限制同时处理的请求数（而非速率）
- 使用信号量（Semaphore）实现
- 请求开始时获取许可，结束时释放

**实现：**
```java
public class ConcurrencyLimiter {
    private final Semaphore semaphore;
    
    public ConcurrencyLimiter(int maxConcurrency) {
        this.semaphore = new Semaphore(maxConcurrency);
    }
    
    public boolean tryAcquire() {
        return semaphore.tryAcquire();
    }
    
    public boolean tryAcquire(long timeout, TimeUnit unit) 
            throws InterruptedException {
        return semaphore.tryAcquire(timeout, unit);
    }
    
    public void release() {
        semaphore.release();
    }
}

// 使用示例
ConcurrencyLimiter limiter = new ConcurrencyLimiter(100);

public void handleRequest() {
    if (limiter.tryAcquire()) {
        try {
            // 处理请求
            processRequest();
        } finally {
            limiter.release();
        }
    } else {
        // 拒绝请求
        throw new TooManyRequestsException();
    }
}
```

**适用场景：**
- 数据库连接池
- 线程池
- 保护有限资源
- 防止资源耗尽

**与速率限流的区别：**
- 速率限流：控制单位时间内的请求数
- 并发限流：控制同时进行的请求数

#### 6. 预测式限流（Predictive Rate Limiting）

**原理：**
- 基于历史数据预测未来流量
- 提前调整限流策略
- 结合机器学习算法

**实现思路：**
```java
public class PredictiveRateLimiter {
    private final TimeSeriesPredictor predictor;
    private final RateLimiter rateLimiter;
    
    public void adjustBasedOnPrediction() {
        // 获取历史流量数据
        List<Double> historicalTraffic = getHistoricalTraffic();
        
        // 预测未来流量
        double predictedTraffic = predictor.predict(historicalTraffic);
        
        // 根据预测调整限流阈值
        if (predictedTraffic > threshold) {
            rateLimiter.setRate(predictedTraffic * 0.8);  // 预留20%缓冲
        }
    }
}
```

**应用场景：**
- 电商大促前预热
- 周期性流量波动
- 智能流量调度

## 五、动态滑动窗口限流

### 15. 什么是动态滑动窗口限流？

动态滑动窗口是滑动窗口算法的增强版本，核心思想是**不再使用固定的窗口大小和阈值，而是根据实时情况动态调整**。

#### 1. 自适应滑动窗口（Adaptive Sliding Window）

**原理：**
- 根据系统负载动态调整窗口大小和限流阈值
- 流量低时放宽限制，流量高时收紧
- 结合系统指标（CPU、响应时间）自动调节

**实现：**
```java
public class AdaptiveSlidingWindow {
    private final Queue<Long> requestTimestamps = new LinkedList<>();
    private volatile long windowSize = 1000;  // 初始1秒
    private volatile int limit = 100;         // 初始100 QPS
    
    public synchronized boolean tryAcquire() {
        long now = System.currentTimeMillis();
        
        // 动态调整窗口大小和阈值
        adjustWindowParameters();
        
        // 移除窗口外的请求
        long boundary = now - windowSize;
        while (!requestTimestamps.isEmpty() 
                && requestTimestamps.peek() <= boundary) {
            requestTimestamps.poll();
        }
        
        if (requestTimestamps.size() < limit) {
            requestTimestamps.offer(now);
            return true;
        }
        return false;
    }
    
    private void adjustWindowParameters() {
        double cpuUsage = SystemMonitor.getCpuUsage();
        double avgResponseTime = SystemMonitor.getAvgResponseTime();
        
        if (cpuUsage > 0.8 || avgResponseTime > 1000) {
            // 系统压力大：缩小窗口，降低阈值
            windowSize = Math.max(500, windowSize - 100);
            limit = Math.max(50, (int)(limit * 0.9));
        } else if (cpuUsage < 0.5 && avgResponseTime < 500) {
            // 系统压力小：扩大窗口，提高阈值
            windowSize = Math.min(2000, windowSize + 100);
            limit = Math.min(200, (int)(limit * 1.1));
        }
    }
}
```

#### 2. 多级滑动窗口（Multi-Level Sliding Window）

**原理：**
- 同时维护多个不同时间粒度的窗口
- 例如：1秒、10秒、1分钟窗口
- 任一窗口超限则触发限流

**实现：**
```java
public class MultiLevelSlidingWindow {
    private final SlidingWindow window1s;   // 1秒窗口
    private final SlidingWindow window10s;  // 10秒窗口
    private final SlidingWindow window1m;   // 1分钟窗口
    
    public MultiLevelSlidingWindow() {
        this.window1s = new SlidingWindow(1000, 100);    // 1秒100个
        this.window10s = new SlidingWindow(10000, 800);  // 10秒800个
        this.window1m = new SlidingWindow(60000, 4000);  // 1分钟4000个
    }
    
    public boolean tryAcquire() {
        // 所有窗口都要检查
        return window1s.tryAcquire() 
            && window10s.tryAcquire() 
            && window1m.tryAcquire();
    }
}

class SlidingWindow {
    private final Queue<Long> timestamps = new LinkedList<>();
    private final long windowSize;
    private final int limit;
    
    public SlidingWindow(long windowSize, int limit) {
        this.windowSize = windowSize;
        this.limit = limit;
    }
    
    public synchronized boolean tryAcquire() {
        long now = System.currentTimeMillis();
        long boundary = now - windowSize;
        
        // 清理过期记录
        while (!timestamps.isEmpty() && timestamps.peek() <= boundary) {
            timestamps.poll();
        }
        
        if (timestamps.size() < limit) {
            timestamps.offer(now);
            return true;
        }
        return false;
    }
}
```

**优点：**
- 多维度保护，更精确
- 防止短时突发和长期超载
- 适合复杂业务场景

**应用场景：**
- 防止短时爆发攻击
- 保护长期稳定性
- 多层次流量控制

#### 3. 加权滑动窗口（Weighted Sliding Window）

**原理：**
- 对不同时间段的请求赋予不同权重
- 越近的请求权重越高
- 更精确地反映当前流量趋势

**实现：**
```java
public class WeightedSlidingWindow {
    private final Queue<RequestRecord> requests = new LinkedList<>();
    private final long windowSize = 1000;
    private final double weightedLimit = 100.0;
    
    static class RequestRecord {
        long timestamp;
        double weight;
        
        RequestRecord(long timestamp, double weight) {
            this.timestamp = timestamp;
            this.weight = weight;
        }
    }
    
    public synchronized boolean tryAcquire() {
        long now = System.currentTimeMillis();
        long boundary = now - windowSize;
        
        // 清理过期请求
        while (!requests.isEmpty() && requests.peek().timestamp <= boundary) {
            requests.poll();
        }
        
        // 计算加权总和
        double weightedSum = 0;
        for (RequestRecord record : requests) {
            // 越近的请求权重越高
            double age = now - record.timestamp;
            double weight = 1.0 - (age / windowSize) * 0.5;  // 权重范围 0.5-1.0
            weightedSum += weight;
        }
        
        if (weightedSum < weightedLimit) {
            requests.offer(new RequestRecord(now, 1.0));
            return true;
        }
        return false;
    }
}
```

**优点：**
- 更关注近期流量
- 对流量趋势更敏感
- 可以更早发现流量异常

#### 4. 预测性滑动窗口（Predictive Sliding Window）

**原理：**
- 基于历史数据预测未来流量
- 提前调整限流策略
- 防止流量突增

**实现思路：**
```java
public class PredictiveSlidingWindow {
    private final Queue<Long> timestamps = new LinkedList<>();
    private volatile int currentLimit = 100;
    private final TrafficPredictor predictor = new TrafficPredictor();
    
    public synchronized boolean tryAcquire() {
        long now = System.currentTimeMillis();
        
        // 每秒更新一次预测
        if (shouldUpdatePrediction(now)) {
            updateLimitBasedOnPrediction();
        }
        
        // 使用动态阈值进行限流
        long boundary = now - 1000;
        while (!timestamps.isEmpty() && timestamps.peek() <= boundary) {
            timestamps.poll();
        }
        
        if (timestamps.size() < currentLimit) {
            timestamps.offer(now);
            return true;
        }
        return false;
    }
    
    private void updateLimitBasedOnPrediction() {
        // 获取最近的流量数据
        List<Integer> recentTraffic = getRecentTrafficStats();
        
        // 预测下一秒的流量
        int predictedTraffic = predictor.predict(recentTraffic);
        
        // 根据预测调整限流阈值
        if (predictedTraffic > currentLimit * 1.5) {
            // 预测流量激增，提前收紧
            currentLimit = (int)(currentLimit * 0.8);
        } else if (predictedTraffic < currentLimit * 0.5) {
            // 预测流量下降，可以放宽
            currentLimit = (int)(currentLimit * 1.2);
        }
    }
}
```

**应用场景：**
- 电商秒杀预热
- 突发事件流量预测
- 智能流量调度

## 六、分布式限流详解

### 16. 什么是分布式限流？

**定义：**
分布式限流是指在**分布式系统中对多个服务实例进行统一的流量控制**，确保所有实例的总流量不超过设定阈值。

**核心问题：**

单机限流在分布式环境下会失效：
```
假设：
- 单机限流配置：100 QPS
- 部署实例数：10个
- 实际总流量：1000 QPS（10倍超限！）
```

**分布式限流的目标：**
- **全局统一**：所有实例共享同一个限流配额
- **准确性**：总流量不超过设定阈值
- **高性能**：不能成为系统瓶颈
- **高可用**：限流服务故障不影响业务

### 17. 分布式限流的主要实现方案

#### 方案一：基于 Redis 的集中式限流

**简单计数器实现：**
```java
public class RedisCounterRateLimiter {
    private final RedisTemplate<String, String> redisTemplate;
    
    public boolean tryAcquire(String key, int limit, int windowSeconds) {
        String redisKey = "rate_limit:" + key;
        
        // 原子递增
        Long count = redisTemplate.opsForValue().increment(redisKey);
        
        // 第一次访问设置过期时间
        if (count == 1) {
            redisTemplate.expire(redisKey, windowSeconds, TimeUnit.SECONDS);
        }
        
        return count <= limit;
    }
}
```

**优点：**
- 实现简单
- 全局准确

**缺点：**
- 有窗口边界问题
- 依赖 Redis
- 每次请求都需要网络调用

#### 方案二：基于 Redis + Lua 脚本的原子限流

**令牌桶 Lua 实现：**
```lua
-- token_bucket.lua
local key = KEYS[1]
local capacity = tonumber(ARGV[1])      -- 桶容量
local rate = tonumber(ARGV[2])          -- 令牌生成速率（每秒）
local requested = tonumber(ARGV[3])     -- 请求令牌数
local now = tonumber(ARGV[4])           -- 当前时间戳（秒）

-- 获取当前桶状态
local bucket = redis.call('HMGET', key, 'tokens', 'last_time')
local tokens = tonumber(bucket[1])
local last_time = tonumber(bucket[2])

-- 初始化
if tokens == nil then
    tokens = capacity
    last_time = now
end

-- 计算新增令牌
local delta_time = math.max(0, now - last_time)
local new_tokens = math.min(capacity, tokens + delta_time * rate)

-- 尝试消费令牌
if new_tokens >= requested then
    new_tokens = new_tokens - requested
    redis.call('HMSET', key, 'tokens', new_tokens, 'last_time', now)
    redis.call('EXPIRE', key, 3600)
    return 1  -- 成功
else
    return 0  -- 失败
end
```

**Java 调用代码：**
```java
public class RedisLuaRateLimiter {
    private final RedisTemplate<String, String> redisTemplate;
    private final RedisScript<Long> script;
    
    public RedisLuaRateLimiter(RedisTemplate<String, String> redisTemplate) {
        this.redisTemplate = redisTemplate;
        // 加载 Lua 脚本
        this.script = RedisScript.of(
            new ClassPathResource("token_bucket.lua"), 
            Long.class
        );
    }
    
    public boolean tryAcquire(String key, int capacity, int rate, int requested) {
        List<String> keys = Collections.singletonList("rate_limit:" + key);
        long now = System.currentTimeMillis() / 1000;
        
        Long result = redisTemplate.execute(
            script, 
            keys, 
            String.valueOf(capacity),
            String.valueOf(rate),
            String.valueOf(requested),
            String.valueOf(now)
        );
        
        return result != null && result == 1;
    }
}
```

**优点：**
- 原子性保证
- 性能好（单次网络调用）
- 逻辑灵活

**缺点：**
- Lua 脚本调试困难
- Redis 单点问题

#### 方案三：本地限流 + 远程限流结合

**两层限流架构：**
```java
public class HybridRateLimiter {
    private final RateLimiter localLimiter;      // 本地限流器
    private final RedisRateLimiter remoteLimiter; // 远程限流器
    private final int localQuota;                 // 本地配额
    private final int globalQuota;                // 全局配额
    
    public HybridRateLimiter(int instanceCount, int globalQuota) {
        this.globalQuota = globalQuota;
        // 本地配额 = 全局配额 / 实例数 * 1.2（预留20%缓冲）
        this.localQuota = (int)(globalQuota / instanceCount * 1.2);
        this.localLimiter = RateLimiter.create(localQuota);
        this.remoteLimiter = new RedisRateLimiter();
    }
    
    public boolean tryAcquire() {
        // 第一层：本地快速拒绝
        if (!localLimiter.tryAcquire()) {
            return false;
        }
        
        // 第二层：远程精确控制
        if (!remoteLimiter.tryAcquire("global", globalQuota)) {
            // 远程限流失败，归还本地令牌
            return false;
        }
        
        return true;
    }
}
```

**配额动态分配：**
```java
public class DynamicQuotaAllocator {
    private final RedisTemplate<String, String> redisTemplate;
    private volatile int localQuota;
    
    // 定期从 Redis 获取配额
    @Scheduled(fixedRate = 1000)  // 每秒更新
    public void refreshQuota() {
        String instanceId = getInstanceId();
        
        // 上报本地使用情况
        int localUsage = getLocalUsage();
        redisTemplate.opsForHash().put(
            "quota_usage", 
            instanceId, 
            String.valueOf(localUsage)
        );
        
        // 获取全局使用情况
        Map<Object, Object> allUsage = redisTemplate.opsForHash()
            .entries("quota_usage");
        
        // 根据使用情况动态分配配额
        localQuota = calculateQuota(allUsage);
    }
    
    private int calculateQuota(Map<Object, Object> allUsage) {
        // 实例使用率高，分配更多配额
        // 实例使用率低，分配更少配额
        int totalUsage = allUsage.values().stream()
            .mapToInt(v -> Integer.parseInt(v.toString()))
            .sum();
        
        int myUsage = Integer.parseInt(
            allUsage.get(getInstanceId()).toString()
        );
        
        // 按使用比例分配
        return (int)(globalQuota * myUsage / totalUsage);
    }
}
```

**优点：**
- 减少网络调用
- 性能高
- 配额可动态调整

**缺点：**
- 实现复杂
- 配额分配需要协调
- 短时可能不够精确

#### 方案四：基于 Nginx + Redis 的网关限流

**Nginx 配置：**
```nginx
http {
    # 使用 Redis 存储限流数据
    lua_shared_dict rate_limit_store 10m;
    
    # 初始化 Redis 连接
    init_by_lua_block {
        local redis = require "resty.redis"
        -- Redis 连接配置
    }
    
    server {
        location /api/ {
            access_by_lua_block {
                local redis = require "resty.redis"
                local red = redis:new()
                
                red:set_timeout(1000)
                local ok, err = red:connect("127.0.0.1", 6379)
                
                if not ok then
                    ngx.log(ngx.ERR, "failed to connect: ", err)
                    return
                end
                
                -- 执行限流逻辑
                local key = "rate_limit:" .. ngx.var.remote_addr
                local count, err = red:incr(key)
                
                if count == 1 then
                    red:expire(key, 1)
                end
                
                if count > 100 then
                    ngx.status = 429
                    ngx.say("Too Many Requests")
                    return ngx.exit(429)
                end
            }
            
            proxy_pass http://backend;
        }
    }
}
```

**优点：**
- 统一入口控制
- 性能极高
- 减轻后端压力

**缺点：**
- 需要 Nginx 支持
- 配置相对复杂

#### 方案五：基于 Zookeeper 的分布式锁限流

**实现思路：**
```java
public class ZookeeperRateLimiter {
    private final CuratorFramework client;
    private final String lockPath = "/rate_limit/locks";
    
    public boolean tryAcquire(String key, int limit) {
        String path = lockPath + "/" + key;
        
        try {
            // 创建临时顺序节点
            String nodePath = client.create()
                .creatingParentsIfNeeded()
                .withMode(CreateMode.EPHEMERAL_SEQUENTIAL)
                .forPath(path + "/lock_");
            
            // 获取所有子节点
            List<String> children = client.getChildren().forPath(path);
            Collections.sort(children);
            
            // 检查当前节点排名
            int index = children.indexOf(nodePath.substring(path.length() + 1));
            
            if (index < limit) {
                return true;  // 获取到配额
            } else {
                // 删除节点
                client.delete().forPath(nodePath);
                return false;
            }
        } catch (Exception e) {
            return false;
        }
    }
}
```

**优点：**
- 强一致性
- 天然分布式

**缺点：**
- 性能较低
- 依赖 Zookeeper
- 实现复杂

### 18. 分布式限流需要考虑的问题

#### 1. 时钟同步问题

**问题：**
- 不同服务器时钟可能不一致
- 导致限流计算不准确

**解决方案：**
```java
// 使用 Redis 时间戳
public long getRedisTimestamp() {
    List<Object> time = redisTemplate.execute(
        (RedisCallback<List<Object>>) connection -> 
            connection.time()
    );
    
    if (time != null && time.size() == 2) {
        long seconds = Long.parseLong(time.get(0).toString());
        long microseconds = Long.parseLong(time.get(1).toString());
        return seconds * 1000 + microseconds / 1000;
    }
    
    return System.currentTimeMillis();
}
```

#### 2. 网络延迟

**问题：**
- 每次限流判断都需要网络调用
- 延迟影响性能

**解决方案：**
- 本地缓存 + 远程校验
- 批量获取配额
- 异步更新

#### 3. Redis 单点故障

**解决方案：**

**主从模式：**
```yaml
spring:
  redis:
    sentinel:
      master: mymaster
      nodes:
        - 192.168.1.1:26379
        - 192.168.1.2:26379
        - 192.168.1.3:26379
```

**集群模式：**
```yaml
spring:
  redis:
    cluster:
      nodes:
        - 192.168.1.1:6379
        - 192.168.1.2:6379
        - 192.168.1.3:6379
```

**降级策略：**
```java
public boolean tryAcquire() {
    try {
        return redisRateLimiter.tryAcquire();
    } catch (Exception e) {
        // Redis 故障，降级到本地限流
        log.warn("Redis rate limiter failed, fallback to local", e);
        return localRateLimiter.tryAcquire();
    }
}
```

#### 4. 性能优化

**Pipeline 批量操作：**
```java
public List<Boolean> tryAcquireBatch(List<String> keys) {
    return redisTemplate.executePipelined(
        (RedisCallback<Object>) connection -> {
            for (String key : keys) {
                connection.incr(key.getBytes());
            }
            return null;
        }
    );
}
```

**本地缓存预热：**
```java
@Cacheable(value = "rate_limit_config", key = "#key")
public RateLimitConfig getConfig(String key) {
    return configService.getConfig(key);
}
```

## 七、实战类

### 19. Guava RateLimiter 使用的是哪种算法？

Guava RateLimiter 使用的是**令牌桶算法的变种**。

**特点：**
- 支持预热（Warm-up）模式
- 支持平滑突发（Smooth Bursty）模式
- 允许预支令牌（借用未来的令牌）

**使用示例：**
```java
// 每秒生成5个令牌
RateLimiter limiter = RateLimiter.create(5.0);

// 获取1个令牌，阻塞直到获取成功
limiter.acquire();

// 尝试获取，最多等待1秒
boolean success = limiter.tryAcquire(1, TimeUnit.SECONDS);

// 预热模式：3秒内从冷启动到稳定速率
RateLimiter warmupLimiter = RateLimiter.create(5.0, 3, TimeUnit.SECONDS);
```

### 12. Nginx 限流使用什么算法？

Nginx 主要使用**漏桶算法**。

**limit_req 模块：**
```nginx
# 定义限流区域：每个IP每秒10个请求
limit_req_zone $binary_remote_addr zone=mylimit:10m rate=10r/s;

server {
    location /api/ {
        # 应用限流，允许突发5个请求
        limit_req zone=mylimit burst=5 nodelay;
        
        # 超限返回503
        limit_req_status 503;
    }
}
```

**参数说明：**
- `rate`：漏出速率
- `burst`：桶容量（允许突发）
- `nodelay`：不延迟处理突发请求

### 20. 美团 Octo 的限流实现方式

美团的限流集成在 **Octo（美团的服务治理框架）** 中，采用多种限流方式组合。

#### 1. 核心限流算法：令牌桶

Octo 主要采用**令牌桶算法**作为核心限流机制：

**特点：**
- 支持平滑突发流量
- 可配置令牌生成速率
- 支持预热（Warm-up）机制
- 基于 Guava RateLimiter 改进

**实现示例：**
```java
public class OctoRateLimiter {
    private final RateLimiter rateLimiter;
    private final int warmupPeriod;  // 预热时长（秒）
    
    public OctoRateLimiter(double permitsPerSecond, int warmupPeriod) {
        if (warmupPeriod > 0) {
            // 带预热的令牌桶
            this.rateLimiter = RateLimiter.create(
                permitsPerSecond, 
                warmupPeriod, 
                TimeUnit.SECONDS
            );
        } else {
            // 普通令牌桶
            this.rateLimiter = RateLimiter.create(permitsPerSecond);
        }
        this.warmupPeriod = warmupPeriod;
    }
    
    public boolean tryAcquire(int permits, long timeout) {
        return rateLimiter.tryAcquire(permits, timeout, TimeUnit.MILLISECONDS);
    }
}
```

#### 2. 多维度限流

Octo 支持多个维度的限流控制：

**服务级限流：**
```java
@OctoService(
    serviceName = "com.meituan.UserService",
    rateLimit = @RateLimit(qps = 10000)
)
public class UserServiceImpl implements UserService {
    // 整个服务限流 10000 QPS
}
```

**方法级限流：**
```java
public class UserServiceImpl implements UserService {
    
    @RateLimit(qps = 1000, warmup = 5)
    public User getUserById(Long userId) {
        // 该方法限流 1000 QPS，预热 5 秒
    }
    
    @RateLimit(qps = 500)
    public List<User> batchGetUsers(List<Long> userIds) {
        // 该方法限流 500 QPS
    }
}
```

**调用方限流（区分不同调用方）：**
```java
@RateLimit(
    qps = 1000,
    appLimits = {
        @AppLimit(appKey = "order-service", qps = 500),
        @AppLimit(appKey = "payment-service", qps = 300),
        @AppLimit(appKey = "default", qps = 200)
    }
)
public User getUserById(Long userId) {
    // 订单服务：500 QPS
    // 支付服务：300 QPS
    // 其他服务：200 QPS
}
```

**分组限流：**
```java
@RateLimit(
    qps = 1000,
    groupLimits = {
        @GroupLimit(group = "vip", qps = 600),
        @GroupLimit(group = "normal", qps = 400)
    }
)
public User getUserById(Long userId) {
    // VIP 用户：600 QPS
    // 普通用户：400 QPS
}
```

#### 3. 分布式限流实现

**本地限流 + 集中式限流结合：**

```java
public class OctoDistributedRateLimiter {
    private final RateLimiter localLimiter;           // 本地令牌桶
    private final RedisRateLimiter remoteLimiter;     // Redis 全局限流
    private final String serviceName;
    private final int globalQps;
    private final int instanceCount;
    
    public OctoDistributedRateLimiter(String serviceName, int globalQps) {
        this.serviceName = serviceName;
        this.globalQps = globalQps;
        this.instanceCount = getInstanceCount();  // 从注册中心获取
        
        // 本地配额 = 全局配额 / 实例数 * 1.2
        int localQps = (int)(globalQps / instanceCount * 1.2);
        this.localLimiter = RateLimiter.create(localQps);
        this.remoteLimiter = new RedisRateLimiter();
    }
    
    public boolean tryAcquire() {
        // 第一层：本地快速判断
        if (!localLimiter.tryAcquire()) {
            return false;
        }
        
        // 第二层：远程精确控制（采样检查，减少网络开销）
        if (shouldCheckRemote()) {
            return remoteLimiter.tryAcquire(serviceName, globalQps);
        }
        
        return true;
    }
    
    private boolean shouldCheckRemote() {
        // 10% 的请求进行远程校验
        return ThreadLocalRandom.current().nextInt(100) < 10;
    }
}
```

**配额动态分配策略：**

```java
public class DynamicQuotaManager {
    private final RedisTemplate<String, String> redisTemplate;
    private volatile int localQuota;
    
    // 每秒更新配额
    @Scheduled(fixedRate = 1000)
    public void refreshQuota() {
        String instanceId = getInstanceId();
        String quotaKey = "quota:" + serviceName;
        
        // 1. 上报本地使用情况
        int localUsage = getLocalUsageInLastSecond();
        redisTemplate.opsForHash().put(
            quotaKey + ":usage", 
            instanceId, 
            String.valueOf(localUsage)
        );
        
        // 2. 获取所有实例的使用情况
        Map<Object, Object> allUsage = redisTemplate.opsForHash()
            .entries(quotaKey + ":usage");
        
        // 3. 动态分配配额
        localQuota = calculateDynamicQuota(allUsage);
    }
    
    private int calculateDynamicQuota(Map<Object, Object> allUsage) {
        int totalUsage = allUsage.values().stream()
            .mapToInt(v -> Integer.parseInt(v.toString()))
            .sum();
        
        if (totalUsage == 0) {
            // 平均分配
            return globalQps / allUsage.size();
        }
        
        int myUsage = Integer.parseInt(
            allUsage.get(getInstanceId()).toString()
        );
        
        // 按使用比例分配（使用多的分配多）
        return (int)(globalQps * myUsage / totalUsage);
    }
}
```

**借用机制（实例间配额借用）：**

```java
public class QuotaBorrowManager {
    private final RedisTemplate<String, String> redisTemplate;
    
    public boolean tryBorrowQuota(String instanceId, int amount) {
        String borrowKey = "quota:borrow:" + serviceName;
        
        // 尝试从配额池借用
        Long available = redisTemplate.opsForValue()
            .decrement(borrowKey, amount);
        
        if (available != null && available >= 0) {
            // 借用成功
            recordBorrow(instanceId, amount);
            return true;
        } else {
            // 借用失败，归还
            redisTemplate.opsForValue().increment(borrowKey, amount);
            return false;
        }
    }
    
    // 定期归还配额
    @Scheduled(fixedRate = 1000)
    public void returnQuota() {
        int unused = getUnusedQuota();
        if (unused > 0) {
            String borrowKey = "quota:borrow:" + serviceName;
            redisTemplate.opsForValue().increment(borrowKey, unused);
        }
    }
}
```

#### 4. 自适应限流

Octo 支持自适应限流（类似 Sentinel）：

```java
public class OctoAdaptiveRateLimiter {
    private volatile int currentQps;
    private final int maxQps;
    private final int minQps;
    
    // 系统指标监控
    private final SystemMetrics metrics;
    
    public OctoAdaptiveRateLimiter(int maxQps, int minQps) {
        this.maxQps = maxQps;
        this.minQps = minQps;
        this.currentQps = maxQps;
        this.metrics = new SystemMetrics();
    }
    
    // 每秒调整一次
    @Scheduled(fixedRate = 1000)
    public void adjustQps() {
        double cpuUsage = metrics.getCpuUsage();
        double memoryUsage = metrics.getMemoryUsage();
        long avgResponseTime = metrics.getAvgResponseTime();
        double errorRate = metrics.getErrorRate();
        
        // 计算系统负载分数（0-1）
        double loadScore = calculateLoadScore(
            cpuUsage, memoryUsage, avgResponseTime, errorRate
        );
        
        if (loadScore > 0.8) {
            // 系统压力大，降低 QPS
            currentQps = Math.max(minQps, (int)(currentQps * 0.9));
        } else if (loadScore < 0.5) {
            // 系统压力小，提高 QPS
            currentQps = Math.min(maxQps, (int)(currentQps * 1.1));
        }
        
        // 更新限流器
        updateRateLimiter(currentQps);
    }
    
    private double calculateLoadScore(
            double cpu, double memory, long rt, double errorRate) {
        // 加权计算负载分数
        return cpu * 0.3 + memory * 0.2 + 
               (rt / 1000.0) * 0.3 + errorRate * 0.2;
    }
}
```

#### 5. 配置中心集成

Octo 通过 MCC（美团配置中心）动态下发限流规则：

```java
@Component
public class RateLimitConfigListener {
    
    @MCCListener(key = "rate.limit.config")
    public void onConfigChange(String newConfig) {
        RateLimitConfig config = JSON.parseObject(
            newConfig, RateLimitConfig.class
        );
        
        // 动态更新限流配置
        updateRateLimitConfig(config);
    }
    
    private void updateRateLimitConfig(RateLimitConfig config) {
        for (ServiceLimit limit : config.getServiceLimits()) {
            RateLimiter limiter = rateLimiters.get(limit.getServiceName());
            if (limiter != null) {
                // 动态调整速率
                limiter.setRate(limit.getQps());
            }
        }
    }
}
```

**配置示例：**
```yaml
rate_limit:
  services:
    - name: com.meituan.UserService
      qps: 10000
      warmup: 5
      methods:
        - name: getUserById
          qps: 1000
        - name: batchGetUsers
          qps: 500
      app_limits:
        - app: order-service
          qps: 5000
        - app: payment-service
          qps: 3000
```

#### 6. 降级策略

限流触发后的处理机制：

```java
public class RateLimitFallbackHandler {
    
    public Object handleRateLimit(
            ProceedingJoinPoint pjp, 
            RateLimit rateLimit) throws Throwable {
        
        if (!rateLimiter.tryAcquire()) {
            // 根据配置的降级策略处理
            switch (rateLimit.fallback()) {
                case FAIL_FAST:
                    throw new RateLimitException("Rate limit exceeded");
                    
                case RETURN_DEFAULT:
                    return getDefaultValue(pjp);
                    
                case RETURN_CACHE:
                    return getCachedValue(pjp);
                    
                case DEGRADE_SERVICE:
                    return degradeService(pjp);
                    
                case QUEUE_WAIT:
                    return queueAndWait(pjp, rateLimit.timeout());
                    
                default:
                    throw new RateLimitException("Rate limit exceeded");
            }
        }
        
        return pjp.proceed();
    }
}
```

#### 7. 监控和告警

```java
@Component
public class RateLimitMonitor {
    
    @Scheduled(fixedRate = 60000)  // 每分钟统计
    public void reportMetrics() {
        RateLimitMetrics metrics = collectMetrics();
        
        // 上报到监控系统
        MetricsReporter.report("rate_limit.total", metrics.getTotalRequests());
        MetricsReporter.report("rate_limit.rejected", metrics.getRejectedRequests());
        MetricsReporter.report("rate_limit.pass_rate", metrics.getPassRate());
        
        // 告警检查
        if (metrics.getPassRate() < 0.5) {
            AlertManager.alert(
                "Rate limit pass rate too low: " + metrics.getPassRate()
            );
        }
    }
}
```

### 13. 设计一个支持多维度限流的系统

**需求分析：**
- 用户级限流：每个用户的请求限制
- IP级限流：防止单个IP攻击
- 接口级限流：保护特定接口
- 全局限流：整体流量控制

**设计方案：**

```java
public class MultiDimensionRateLimiter {
    private final Map<String, RateLimiter> limiters = new ConcurrentHashMap<>();
    
    public boolean tryAcquire(RateLimitContext context) {
        // 按优先级检查各维度限流
        return checkGlobalLimit(context)
            && checkApiLimit(context)
            && checkUserLimit(context)
            && checkIpLimit(context);
    }
    
    private boolean checkGlobalLimit(RateLimitContext context) {
        String key = "global";
        return getLimiter(key, 10000).tryAcquire();
    }
    
    private boolean checkApiLimit(RateLimitContext context) {
        String key = "api:" + context.getApi();
        return getLimiter(key, 1000).tryAcquire();
    }
    
    private boolean checkUserLimit(RateLimitContext context) {
        String key = "user:" + context.getUserId();
        return getLimiter(key, 100).tryAcquire();
    }
    
    private boolean checkIpLimit(RateLimitContext context) {
        String key = "ip:" + context.getIp();
        return getLimiter(key, 200).tryAcquire();
    }
    
    private RateLimiter getLimiter(String key, double permitsPerSecond) {
        return limiters.computeIfAbsent(key, 
            k -> RateLimiter.create(permitsPerSecond));
    }
}
```

**配置化管理：**
```yaml
rate_limits:
  global:
    rate: 10000
    algorithm: token_bucket
  
  apis:
    - path: /api/login
      rate: 100
      burst: 10
    - path: /api/query
      rate: 1000
      burst: 50
  
  user:
    default_rate: 100
    vip_rate: 500
  
  ip:
    rate: 200
    blacklist:
      - 192.168.1.100
```

**组合策略：**
- AND：所有维度都通过才放行（更严格）
- OR：任一维度通过即放行（更宽松）
- 优先级：按重要性依次检查

---

## 附录：常见面试追问

1. **如何监控限流效果？**
   - 记录限流次数、通过率
   - 监控响应时间变化
   - 告警机制

2. **限流配置如何动态调整？**
   - 配置中心（Apollo、Nacos）
   - 实时生效，无需重启

3. **如何测试限流功能？**
   - 压测工具（JMeter、Gatling）
   - 验证限流阈值准确性
   - 测试降级策略

4. **限流和熔断的区别？**
   - 限流：控制流量速率
   - 熔断：故障时快速失败
   - 两者通常配合使用
