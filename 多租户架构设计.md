# 多租户架构设计

## 核心要点（快速回答）

**Q: 商品系统如何支持多业态（餐饮、超市、药店）？**
采用"统一平台+业态扩展"模式。核心商品模型统一（名称、价格、库存、状态），业态差异通过扩展字段和扩展表支持。比如药店有"处方药"标记，超市有"保质期"字段，这些通过JSON扩展属性存储，不污染主表。

**Q: 是用同一套系统还是分开？**
同一套系统，但做了业态隔离。代码层面是一套，数据按商家ID隔离。业态差异通过配置驱动：不同业态有不同的商品模板、不同的规格配置、不同的校验规则。新增业态只需配置，不需要改代码。

**Q: 如何做到既统一又灵活？**
三个关键设计：
1）核心模型抽象：提取各业态共性，形成统一商品模型；
2）扩展机制：JSON字段存储业态特有属性，扩展表存储业态特有实体；
3）配置驱动：业态规则（校验规则、展示模板）通过配置中心管理。

**Q: 多业态带来了哪些挑战？**
三个挑战：1）模型抽象难度高：要找到各业态的最大公约数；2）规则复杂：不同业态校验规则不同（如药店需要资质校验）；3）展示差异：不同业态的商品详情页结构不同。我们通过"核心统一、差异配置"的方式解决。

---

## 一、多业态背景

### 1.1 美团外卖的业态类型

```
美团外卖支持的业态：

1. 餐饮（占比70%）
   - 正餐、快餐、小吃
   - 饮品、甜点
   - 火锅、烧烤

2. 超市便利（占比15%）
   - 便利店
   - 超市
   - 水果生鲜

3. 药店（占比5%）
   - 药品
   - 保健品
   - 医疗器械

4. 其他（占比10%）
   - 鲜花
   - 蛋糕
   - 宠物用品
```

### 1.2 各业态差异

| 维度 | 餐饮 | 超市 | 药店 |
|-----|-----|-----|-----|
| 库存模式 | 产能（能做多少）| 实物（有多少件）| 实物+批次 |
| 规格特点 | 大小份、口味 | 重量、包装 | 剂量、规格 |
| 特殊属性 | 辣度、温度 | 保质期、产地 | 处方、禁忌 |
| 校验规则 | 营业时间 | 库存、效期 | 处方、资质 |
| 履约方式 | 即时制作 | 拣货打包 | 审核配送 |

---

## 二、架构设计

### 2.1 设计原则

```
多租户架构设计原则：

1. 核心统一
   - 统一的商品基础模型
   - 统一的数据库表结构
   - 统一的API接口

2. 差异扩展
   - 业态特有属性用扩展字段
   - 业态特有逻辑用策略模式
   - 业态特有校验用规则引擎

3. 配置驱动
   - 业态规则可配置
   - 展示模板可配置
   - 校验规则可配置

4. 数据隔离
   - 按商家ID隔离数据
   - 业态标签用于过滤
   - 不同业态可独立扩展
```

### 2.2 整体架构

```
多业态架构：

                    ┌─────────────────────────┐
                    │       统一接入层         │
                    │    (API Gateway)        │
                    └───────────┬─────────────┘
                                │
         ┌──────────────────────┼──────────────────────┐
         │                      │                      │
         ▼                      ▼                      ▼
┌─────────────┐        ┌─────────────┐        ┌─────────────┐
│  餐饮模块   │        │  超市模块    │        │  药店模块   │
│ (扩展逻辑) │        │ (扩展逻辑)   │        │ (扩展逻辑)  │
└──────┬──────┘        └──────┬──────┘        └──────┬──────┘
       │                      │                      │
       └──────────────────────┼──────────────────────┘
                              │
                              ▼
                    ┌─────────────────────────┐
                    │     商品核心服务         │
                    │   (统一模型和接口)       │
                    └───────────┬─────────────┘
                                │
                                ▼
                    ┌─────────────────────────┐
                    │      数据存储层          │
                    │ (统一表结构+扩展字段)    │
                    └─────────────────────────┘
```

### 2.3 业态标识

```sql
-- 商家表中的业态标识
CREATE TABLE merchant (
    id BIGINT PRIMARY KEY,
    name VARCHAR(100),
    business_type VARCHAR(20) NOT NULL,  -- 业态类型
    -- RESTAURANT: 餐饮
    -- SUPERMARKET: 超市
    -- PHARMACY: 药店
    -- FLORIST: 鲜花
    -- BAKERY: 蛋糕
    -- OTHER: 其他
    sub_type VARCHAR(50),                 -- 子业态
    -- 餐饮：CHINESE/WESTERN/JAPANESE/KOREAN...
    -- 超市：CONVENIENCE/SUPERMARKET/FRESH...
    ...
);

-- 商品表中关联业态
CREATE TABLE product (
    id BIGINT PRIMARY KEY,
    merchant_id BIGINT NOT NULL,
    business_type VARCHAR(20) NOT NULL,   -- 冗余业态类型，便于查询
    ...
);
```

---

## 三、统一商品模型

### 3.1 核心模型抽象

```java
// 统一商品基础模型
@Data
public class Product {
    // === 基础信息（所有业态通用）===
    private Long id;
    private Long merchantId;
    private String businessType;      // 业态类型
    private String name;              // 商品名称
    private String description;       // 商品描述
    private String mainImage;         // 主图
    private List<String> images;      // 图片列表
    private Long categoryId;          // 分类ID

    // === 价格信息（所有业态通用）===
    private BigDecimal price;         // 价格
    private BigDecimal originalPrice; // 原价
    private BigDecimal boxPrice;      // 包装费

    // === 状态信息（所有业态通用）===
    private Integer status;           // 状态
    private Integer sortOrder;        // 排序

    // === 规格配料（所有业态通用，结构不同）===
    private List<SpecGroup> specGroups;
    private List<AdditionGroup> additionGroups;

    // === 扩展属性（业态差异）===
    private Map<String, Object> extAttributes;  // 扩展属性
}
```

### 3.2 扩展属性设计

```java
// 餐饮扩展属性
public class RestaurantProductExt {
    private String spicyLevel;        // 辣度
    private String taste;             // 口味
    private Boolean isRecommend;      // 是否推荐
    private List<String> allergens;   // 过敏原
    private Integer prepareTime;      // 制作时间（分钟）
}

// 超市扩展属性
public class SupermarketProductExt {
    private String brand;             // 品牌
    private String origin;            // 产地
    private Date productionDate;      // 生产日期
    private Date expirationDate;      // 保质期
    private String specification;     // 规格（500g/瓶）
    private String barcode;           // 条形码
}

// 药店扩展属性
public class PharmacyProductExt {
    private String approvalNumber;    // 批准文号
    private String manufacturer;      // 生产厂家
    private Boolean isPrescription;   // 是否处方药
    private String dosage;            // 用法用量
    private String contraindication;  // 禁忌
    private String indication;        // 适应症
    private String batchNumber;       // 批号
}
```

### 3.3 数据存储

```sql
-- 统一商品表（核心字段）
CREATE TABLE product (
    id BIGINT PRIMARY KEY,
    merchant_id BIGINT NOT NULL,
    business_type VARCHAR(20) NOT NULL,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    main_image VARCHAR(500),
    images JSON,
    category_id BIGINT,
    price DECIMAL(10,2),
    original_price DECIMAL(10,2),
    box_price DECIMAL(10,2) DEFAULT 0,
    status TINYINT DEFAULT 1,
    sort_order INT DEFAULT 0,

    -- 扩展属性（JSON存储）
    ext_attributes JSON,

    create_time DATETIME,
    update_time DATETIME,
    INDEX idx_merchant (merchant_id),
    INDEX idx_business_type (business_type)
);

-- 业态扩展表示例（药品扩展信息）
CREATE TABLE product_pharmacy_ext (
    id BIGINT PRIMARY KEY,
    product_id BIGINT NOT NULL UNIQUE,
    approval_number VARCHAR(50),
    manufacturer VARCHAR(200),
    is_prescription TINYINT DEFAULT 0,
    dosage VARCHAR(500),
    contraindication TEXT,
    indication TEXT,
    batch_number VARCHAR(50),
    create_time DATETIME,
    update_time DATETIME
);
```

---

## 四、业态扩展机制

### 4.1 策略模式处理业态差异

**为什么用策略模式**：不同业态的处理逻辑不同，如果用if-else会导致代码臃肿且难以维护。策略模式把每个业态的处理逻辑封装成独立的Handler，新增业态只需要新增Handler，不用修改现有代码，符合开闭原则。

**Handler接口设计**：
- getBusinessType()：返回业态标识，用于工厂匹配
- validate()：业态特有的校验规则
- buildDetailVO()：业态特有的详情页结构
- calculateStock()：业态特有的库存计算逻辑

```java
// 业态处理策略接口
public interface BusinessTypeHandler {

    String getBusinessType();

    // 商品创建前置处理
    void beforeCreate(Product product);

    // 商品创建后置处理
    void afterCreate(Product product);

    // 商品校验
    ValidationResult validate(Product product);

    // 构建商品详情VO
    ProductDetailVO buildDetailVO(Product product);

    // 计算库存
    StockInfo calculateStock(Product product);
}

// 餐饮业态处理器
@Component
public class RestaurantHandler implements BusinessTypeHandler {

    @Override
    public String getBusinessType() {
        return "RESTAURANT";
    }

    @Override
    public ValidationResult validate(Product product) {
        ValidationResult result = new ValidationResult();

        // 餐饮特有校验：必须有分类
        if (product.getCategoryId() == null) {
            result.addError("餐饮商品必须选择分类");
        }

        // 餐饮特有校验：价格不能为0
        if (product.getPrice().compareTo(BigDecimal.ZERO) <= 0) {
            result.addError("商品价格必须大于0");
        }

        return result;
    }

    @Override
    public StockInfo calculateStock(Product product) {
        // 餐饮库存：基于产能，通常不限量
        return StockInfo.unlimited();
    }
}

// 药店业态处理器
@Component
public class PharmacyHandler implements BusinessTypeHandler {

    @Override
    public String getBusinessType() {
        return "PHARMACY";
    }

    @Override
    public ValidationResult validate(Product product) {
        ValidationResult result = new ValidationResult();

        PharmacyProductExt ext = getPharmacyExt(product);

        // 药品特有校验：必须有批准文号
        if (StringUtils.isEmpty(ext.getApprovalNumber())) {
            result.addError("药品必须填写批准文号");
        }

        // 药品特有校验：处方药必须有用法用量
        if (ext.getIsPrescription() && StringUtils.isEmpty(ext.getDosage())) {
            result.addError("处方药必须填写用法用量");
        }

        return result;
    }

    @Override
    public StockInfo calculateStock(Product product) {
        // 药品库存：实物库存，需要按批次管理
        return stockService.getPharmacyStock(product.getId());
    }
}
```

### 4.2 处理器工厂

**工厂模式的价值**：业务代码不需要知道有哪些Handler，只需要调用工厂获取。工厂通过Spring的依赖注入自动收集所有Handler，构建映射表。新增业态只需要新增Handler类，工厂自动识别，业务代码无需修改。

**默认处理器**：如果找不到对应业态的Handler，返回默认处理器，保证系统不会因为新业态而崩溃。

```java
@Component
public class BusinessTypeHandlerFactory {

    private Map<String, BusinessTypeHandler> handlerMap = new HashMap<>();

    @Autowired
    public BusinessTypeHandlerFactory(List<BusinessTypeHandler> handlers) {
        for (BusinessTypeHandler handler : handlers) {
            handlerMap.put(handler.getBusinessType(), handler);
        }
    }

    public BusinessTypeHandler getHandler(String businessType) {
        BusinessTypeHandler handler = handlerMap.get(businessType);
        if (handler == null) {
            // 默认处理器
            return handlerMap.get("DEFAULT");
        }
        return handler;
    }
}

// 使用示例
@Service
public class ProductService {

    @Autowired
    private BusinessTypeHandlerFactory handlerFactory;

    public void createProduct(Product product) {
        BusinessTypeHandler handler = handlerFactory.getHandler(
            product.getBusinessType());

        // 前置处理
        handler.beforeCreate(product);

        // 校验
        ValidationResult result = handler.validate(product);
        if (!result.isValid()) {
            throw new BusinessException(result.getErrors());
        }

        // 保存
        productDao.insert(product);

        // 后置处理
        handler.afterCreate(product);
    }
}
```

---

## 五、配置驱动

### 5.1 业态配置中心

**配置驱动的好处**：把业态规则从代码中抽离出来，放到配置中心。新增业态或修改规则只需要改配置，不需要发版。这大大提高了系统的灵活性，也降低了出错风险。

**配置内容说明**：
- **productTemplate**：定义必填字段、可选字段、扩展字段
- **validationRules**：定义校验规则，支持条件校验
- **displayConfig**：定义展示模板，不同业态可以有不同的详情页样式

```java
// 业态配置
@Data
public class BusinessTypeConfig {
    private String businessType;
    private String name;

    // 商品模板配置
    private ProductTemplate productTemplate;

    // 规格配置
    private SpecConfig specConfig;

    // 校验规则配置
    private List<ValidationRule> validationRules;

    // 展示配置
    private DisplayConfig displayConfig;
}

// 商品模板
@Data
public class ProductTemplate {
    // 必填字段
    private List<String> requiredFields;

    // 可选字段
    private List<String> optionalFields;

    // 扩展字段定义
    private List<ExtFieldDefinition> extFields;

    // 默认值
    private Map<String, Object> defaultValues;
}

// 扩展字段定义
@Data
public class ExtFieldDefinition {
    private String name;           // 字段名
    private String label;          // 显示名
    private String type;           // 类型：STRING/NUMBER/DATE/ENUM
    private Boolean required;      // 是否必填
    private List<String> options;  // 枚举选项
    private String defaultValue;   // 默认值
}
```

### 5.2 配置示例

```json
{
    "businessType": "PHARMACY",
    "name": "药店",
    "productTemplate": {
        "requiredFields": ["name", "price", "mainImage", "categoryId"],
        "optionalFields": ["description", "images"],
        "extFields": [
            {
                "name": "approvalNumber",
                "label": "批准文号",
                "type": "STRING",
                "required": true
            },
            {
                "name": "isPrescription",
                "label": "是否处方药",
                "type": "BOOLEAN",
                "required": true,
                "defaultValue": "false"
            },
            {
                "name": "dosage",
                "label": "用法用量",
                "type": "TEXT",
                "required": false
            },
            {
                "name": "contraindication",
                "label": "禁忌",
                "type": "TEXT",
                "required": false
            }
        ]
    },
    "validationRules": [
        {
            "field": "approvalNumber",
            "rule": "REGEX",
            "pattern": "^国药准字[A-Z]\\d{8}$",
            "message": "批准文号格式不正确"
        },
        {
            "condition": "isPrescription == true",
            "field": "dosage",
            "rule": "NOT_EMPTY",
            "message": "处方药必须填写用法用量"
        }
    ],
    "displayConfig": {
        "detailPageTemplate": "pharmacy_detail",
        "listItemTemplate": "pharmacy_list_item",
        "showFields": ["approvalNumber", "manufacturer", "dosage"]
    }
}
```

### 5.3 配置驱动的校验

**配置驱动校验的实现**：不再硬编码校验逻辑，而是根据配置动态执行校验。配置定义了哪些字段必填、扩展字段的校验规则、条件校验等。校验器读取配置，按照配置执行校验。

**优势**：
1. 新增字段校验不需要改代码
2. 不同业态可以有不同的校验规则
3. 校验规则可以运行时修改

```java
@Service
public class ConfigDrivenValidator {

    @Autowired
    private BusinessTypeConfigService configService;

    public ValidationResult validate(Product product) {
        BusinessTypeConfig config = configService.getConfig(
            product.getBusinessType());

        ValidationResult result = new ValidationResult();

        // 基于配置的必填校验
        for (String field : config.getProductTemplate().getRequiredFields()) {
            Object value = getFieldValue(product, field);
            if (value == null || "".equals(value)) {
                result.addError(field + " 不能为空");
            }
        }

        // 基于配置的扩展字段校验
        for (ExtFieldDefinition extField : config.getProductTemplate().getExtFields()) {
            if (extField.getRequired()) {
                Object value = product.getExtAttributes().get(extField.getName());
                if (value == null || "".equals(value)) {
                    result.addError(extField.getLabel() + " 不能为空");
                }
            }
        }

        // 基于配置的规则校验
        for (ValidationRule rule : config.getValidationRules()) {
            if (!evaluateRule(product, rule)) {
                result.addError(rule.getMessage());
            }
        }

        return result;
    }
}
```

---

## 六、数据隔离

### 6.1 商家级隔离

**数据隔离的重要性**：多租户系统最重要的是数据隔离，商家A不能看到商家B的数据。通过AOP切面自动注入merchantId到查询条件，保证所有查询都带上商家过滤，开发者不会遗漏。

**实现技巧**：
- 使用ThreadLocal存储当前商家ID（从登录态解析）
- 切面拦截所有打了@MerchantIsolation注解的方法
- 自动给查询参数注入merchantId

```java
// 查询时自动加上商家ID过滤
@Aspect
@Component
public class MerchantIsolationAspect {

    @Around("@annotation(MerchantIsolation)")
    public Object isolate(ProceedingJoinPoint pjp) throws Throwable {
        // 获取当前商家ID
        Long merchantId = MerchantContext.getCurrentMerchantId();

        if (merchantId == null) {
            throw new BusinessException("商家ID不能为空");
        }

        // 注入商家ID到查询参数
        Object[] args = pjp.getArgs();
        for (Object arg : args) {
            if (arg instanceof MerchantQuery) {
                ((MerchantQuery) arg).setMerchantId(merchantId);
            }
        }

        return pjp.proceed(args);
    }
}

// 使用示例
@MerchantIsolation
public List<Product> listProducts(ProductQuery query) {
    // query中已自动注入merchantId
    return productDao.selectList(query);
}
```

### 6.2 业态级权限

```java
// 业态权限控制
@Service
public class BusinessTypePermissionService {

    // 检查商家是否有权限操作某业态
    public boolean hasPermission(Long merchantId, String businessType) {
        Merchant merchant = merchantService.getById(merchantId);
        return merchant.getBusinessType().equals(businessType);
    }

    // 检查操作权限
    public void checkPermission(Long merchantId, String businessType) {
        if (!hasPermission(merchantId, businessType)) {
            throw new PermissionException("无权操作该业态商品");
        }
    }
}
```

---

## 七、业态扩展示例

### 7.1 新增业态：宠物用品

**新增业态的标准流程**：
1. 定义扩展属性类：宠物用品特有的属性（适用宠物类型、年龄段等）
2. 实现业态处理器：校验逻辑、展示逻辑
3. 添加业态配置：字段定义、校验规则、展示模板

**整个过程不需要修改核心代码，只需要新增类和配置。**

```java
// 1. 定义扩展属性
public class PetSupplyProductExt {
    private String petType;          // 适用宠物：CAT/DOG/BIRD...
    private String ageGroup;         // 适用年龄：PUPPY/ADULT/SENIOR
    private String ingredients;      // 成分
    private String feedingGuide;     // 喂养指南
}

// 2. 实现业态处理器
@Component
public class PetSupplyHandler implements BusinessTypeHandler {

    @Override
    public String getBusinessType() {
        return "PET_SUPPLY";
    }

    @Override
    public ValidationResult validate(Product product) {
        ValidationResult result = new ValidationResult();

        PetSupplyProductExt ext = getPetSupplyExt(product);

        // 宠物用品特有校验
        if (StringUtils.isEmpty(ext.getPetType())) {
            result.addError("必须选择适用宠物类型");
        }

        return result;
    }
}

// 3. 添加业态配置
{
    "businessType": "PET_SUPPLY",
    "name": "宠物用品",
    "productTemplate": {
        "requiredFields": ["name", "price", "mainImage"],
        "extFields": [
            {
                "name": "petType",
                "label": "适用宠物",
                "type": "ENUM",
                "required": true,
                "options": ["CAT", "DOG", "BIRD", "FISH", "OTHER"]
            },
            {
                "name": "ageGroup",
                "label": "适用年龄",
                "type": "ENUM",
                "options": ["PUPPY", "ADULT", "SENIOR", "ALL"]
            }
        ]
    }
}
```

---

## 八、最佳实践

### 8.1 设计原则

```
1. 找最大公约数
   - 分析各业态共性
   - 抽象统一模型
   - 差异放入扩展

2. 配置优于代码
   - 业态规则可配置
   - 新业态不改代码
   - 灵活应对变化

3. 隔离要彻底
   - 数据按商家隔离
   - 逻辑按业态隔离
   - 互不影响

4. 扩展要方便
   - 新增业态成本低
   - 有标准的扩展点
   - 文档要完善
```

### 8.2 常见问题

```
问题1：模型太通用，丢失业态特性
解决：扩展字段+扩展表，保留业态特有信息

问题2：校验规则分散，难以维护
解决：规则引擎+配置中心，集中管理

问题3：展示逻辑复杂，各业态不同
解决：模板化展示，按业态配置模板

问题4：新业态接入成本高
解决：提供标准接入流程和SDK
```
