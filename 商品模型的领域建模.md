# 商品模型的领域建模

## 核心要点（面试快速回答）

**Q: 外卖商品和电商商品有什么本质区别？**
三个核心差异：1）时效性：外卖商品"即时生产"，库存是产能而非实物，电商是实物库存；2）地域性：外卖商品只在配送范围内有效，电商全国可买；3）关联性：外卖商品强依赖商家营业状态，商家休息则商品不可售。这些差异决定了模型设计的不同。

**Q: SPU、SKU在外卖场景下如何应用？**
外卖场景简化了SPU/SKU：一个菜品是一个SPU，不同规格（大份/小份）+不同配料组合形成SKU。但不像电商那样严格区分，因为外卖的规格组合相对简单，我们用"商品+规格+配料"三层结构来表达。

**Q: 商品的规格、属性、标签如何建模？**
分三类：1）规格（必选一项）：如大杯/中杯/小杯，影响价格；2）配料（可多选）：如加珍珠/加椰果，影响价格；3）属性/标签（展示用）：如辣度、口味偏好，不影响价格。规格用规格组管理，配料用配料组管理，属性用KV结构存储。

**Q: 商品模型的核心表结构是什么？**
四张核心表：product（商品主表）、product_spec（规格）、product_addition（配料）、product_sku（SKU，规格+配料的组合）。商品和规格是1:N关系，SKU由规格和配料笛卡尔积生成。

---

## 一、外卖商品 vs 电商商品

### 1.1 本质差异对比

| 维度 | 外卖商品 | 电商商品 |
|-----|---------|---------|
| **库存本质** | 产能（能做多少份）| 实物（有多少件）|
| **时效性** | 即时生产，分钟级 | 预先备货，天级 |
| **地域性** | 配送范围内有效 | 全国/全球可售 |
| **营业状态** | 强依赖商家是否营业 | 独立，24小时可售 |
| **价格变化** | 相对稳定 | 频繁促销 |
| **SKU复杂度** | 简单（规格+配料）| 复杂（多属性组合）|
| **商品生命周期** | 短（菜单常换）| 长（标品）|

### 1.2 外卖商品的特殊性

```
外卖商品的核心特征：

1. 即时性
   - 用户下单后才开始制作
   - 不存在"发货"概念，只有"出餐"
   - 库存是"还能做多少份"，而非"还有多少件"

2. 地域性
   - 商品只在商家配送范围内展示
   - 同一商品在不同区域可能价格不同（商圈定价）
   - 配送距离影响是否可售

3. 时间性
   - 商品可售性依赖商家营业时间
   - 早餐、午餐、晚餐可能是不同商品
   - 限时供应（如下午茶特供）

4. 关联性
   - 商品状态强依赖商家状态
   - 商家休息 = 所有商品不可售
   - 商家被处罚 = 商品下架
```

### 1.3 对模型设计的影响

```
差异导致的模型设计不同：

电商模型：
Product → SPU → SKU → 库存
              ↓
           属性组合

外卖模型：
Product → 规格组 → SKU
       → 配料组 ↗
       → 商家状态（实时关联）
       → 营业时间（动态过滤）
       → 配送范围（地理过滤）
```

---

## 二、外卖商品模型设计

### 2.1 核心概念

```
外卖商品模型的核心概念：

1. 商品（Product）
   - 一个菜品/商品
   - 如：招牌奶茶、黄焖鸡米饭

2. 规格（Spec）
   - 必选一项的属性
   - 如：大杯/中杯/小杯、大份/小份
   - 影响价格

3. 配料（Addition）
   - 可选多项的附加
   - 如：加珍珠、加椰果、加辣
   - 影响价格

4. SKU
   - 规格+配料的组合
   - 决定最终价格和库存
   - 如：大杯+加珍珠+加椰果

5. 分类（Category）
   - 商品的组织方式
   - 如：热销、主食、饮品、小吃
```

### 2.2 实体关系

```
商品模型实体关系：

                    ┌─────────────┐
                    │   商家      │
                    │  Merchant   │
                    └──────┬──────┘
                           │ 1:N
                           ▼
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   分类      │ N:N │   商品      │ 1:N │   规格组    │
│  Category   │◄────│  Product    │────►│  SpecGroup  │
└─────────────┘     └──────┬──────┘     └──────┬──────┘
                           │                    │
                           │ 1:N                │ 1:N
                           ▼                    ▼
                    ┌─────────────┐     ┌─────────────┐
                    │  配料组     │     │   规格      │
                    │ AdditionGrp │     │   Spec      │
                    └──────┬──────┘     └─────────────┘
                           │
                           │ 1:N
                           ▼
                    ┌─────────────┐
                    │   配料      │
                    │  Addition   │
                    └─────────────┘
```

### 2.3 核心表结构

**表设计的思考**：

**商品主表设计要点**：
1. merchant_id + status 建复合索引，因为查询商家商品是最频繁的场景
2. 使用JSON存储图片列表和扩展属性，避免多表关联
3. box_price（包装费）单独字段，因为外卖场景这是必需的
4. min/max_order_count 控制购买数量，防止恶意下单

**商品主表：**
```sql
CREATE TABLE product (
    id BIGINT PRIMARY KEY,
    merchant_id BIGINT NOT NULL,          -- 商家ID
    name VARCHAR(100) NOT NULL,           -- 商品名称
    description VARCHAR(500),             -- 商品描述
    category_id BIGINT,                   -- 分类ID
    main_image VARCHAR(255),              -- 主图
    images JSON,                          -- 图片列表
    base_price DECIMAL(10,2),             -- 基础价格
    box_price DECIMAL(10,2) DEFAULT 0,    -- 包装费
    unit VARCHAR(20),                     -- 单位（份、杯、个）
    status TINYINT DEFAULT 1,             -- 状态：1上架 0下架
    sort_order INT DEFAULT 0,             -- 排序
    sale_count INT DEFAULT 0,             -- 销量
    min_order_count INT DEFAULT 1,        -- 最小起订量
    max_order_count INT DEFAULT 99,       -- 最大购买量
    labels JSON,                          -- 标签（新品、招牌、辣等）
    attributes JSON,                      -- 扩展属性
    create_time DATETIME,
    update_time DATETIME,
    INDEX idx_merchant_status (merchant_id, status),
    INDEX idx_category (category_id)
);
```

**规格组表：**

**规格设计要点**：
1. 规格组和规格是两级结构，规格组是"杯型"，规格是"大杯/中杯/小杯"
2. required字段控制是否必选，max_select控制最多选几个
3. price_diff是相对于基础价格的差值，不是绝对价格，便于商家调整基础价
4. is_default标记默认选项，提升用户体验

```sql
CREATE TABLE product_spec_group (
    id BIGINT PRIMARY KEY,
    product_id BIGINT NOT NULL,
    name VARCHAR(50) NOT NULL,            -- 规格组名称（如：杯型、份量）
    required TINYINT DEFAULT 1,           -- 是否必选
    max_select INT DEFAULT 1,             -- 最多可选几项
    sort_order INT DEFAULT 0,
    INDEX idx_product (product_id)
);

CREATE TABLE product_spec (
    id BIGINT PRIMARY KEY,
    spec_group_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    name VARCHAR(50) NOT NULL,            -- 规格名称（如：大杯、中杯）
    price_diff DECIMAL(10,2) DEFAULT 0,   -- 价格差（相对基础价格）
    is_default TINYINT DEFAULT 0,         -- 是否默认选中
    sort_order INT DEFAULT 0,
    status TINYINT DEFAULT 1,
    INDEX idx_product (product_id),
    INDEX idx_group (spec_group_id)
);
```

**配料组表：**

**配料设计要点**：
1. 配料和规格的区别：规格是必选单选，配料是可选多选
2. min_select和max_select控制选择范围，比如"至少选1个，最多选3个"
3. 配料的price是绝对价格（加2元），不是差值
4. 配料可以关联库存，比如"珍珠"用完了就不能选

```sql
CREATE TABLE product_addition_group (
    id BIGINT PRIMARY KEY,
    product_id BIGINT NOT NULL,
    name VARCHAR(50) NOT NULL,            -- 配料组名称（如：加料、口味）
    required TINYINT DEFAULT 0,           -- 是否必选
    min_select INT DEFAULT 0,             -- 最少选几项
    max_select INT DEFAULT 99,            -- 最多选几项
    sort_order INT DEFAULT 0,
    INDEX idx_product (product_id)
);

CREATE TABLE product_addition (
    id BIGINT PRIMARY KEY,
    addition_group_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    name VARCHAR(50) NOT NULL,            -- 配料名称（如：珍珠、椰果）
    price DECIMAL(10,2) DEFAULT 0,        -- 配料价格
    is_default TINYINT DEFAULT 0,
    sort_order INT DEFAULT 0,
    status TINYINT DEFAULT 1,
    INDEX idx_product (product_id),
    INDEX idx_group (addition_group_id)
);
```

---

## 三、规格与配料设计

### 3.1 规格设计

**规格的特点：**
```
规格（Spec）：
- 必选性：必须选择一个
- 互斥性：同一规格组内只能选一个
- 影响价格：不同规格价格不同
- 影响库存：可以按规格管理库存

典型规格：
- 杯型：大杯/中杯/小杯
- 份量：大份/中份/小份
- 温度：热/冰/常温
- 甜度：全糖/半糖/无糖（有些不影响价格）
```

**规格的数据模型：**
```java
@Data
public class SpecGroup {
    private Long id;
    private Long productId;
    private String name;           // 规格组名称
    private Boolean required;      // 是否必选
    private Integer maxSelect;     // 最多选几个（通常为1）
    private List<Spec> specs;      // 规格列表
}

@Data
public class Spec {
    private Long id;
    private Long specGroupId;
    private String name;           // 规格名称
    private BigDecimal priceDiff;  // 价格差
    private Boolean isDefault;     // 是否默认
}
```

### 3.2 配料设计

**配料的特点：**
```
配料（Addition）：
- 可选性：可以不选
- 可多选：同一配料组内可以选多个
- 叠加价格：选中的配料价格累加
- 独立库存：配料可以有独立库存

典型配料：
- 加料：珍珠、椰果、红豆、仙草
- 加菜：加蛋、加肉、加肠
- 调味：加辣、加醋、加蒜
```

**配料的数据模型：**
```java
@Data
public class AdditionGroup {
    private Long id;
    private Long productId;
    private String name;           // 配料组名称
    private Boolean required;      // 是否必选
    private Integer minSelect;     // 最少选几个
    private Integer maxSelect;     // 最多选几个
    private List<Addition> additions;
}

@Data
public class Addition {
    private Long id;
    private Long additionGroupId;
    private String name;           // 配料名称
    private BigDecimal price;      // 配料价格
    private Boolean isDefault;     // 是否默认选中
}
```

### 3.3 规格与配料的区别

| 维度 | 规格（Spec）| 配料（Addition）|
|-----|------------|----------------|
| 必选性 | 必须选一个 | 可以不选 |
| 选择数量 | 单选 | 可多选 |
| 价格影响 | 替代基础价格 | 叠加到总价 |
| 库存关联 | 可能关联SKU库存 | 通常独立库存 |
| 典型场景 | 大小、温度、甜度 | 加料、配菜 |

---

## 四、SKU设计

### 4.1 SKU的定义

```
外卖场景的SKU：

SKU = 商品 + 规格组合 + 配料组合

示例：
商品：招牌奶茶
规格：大杯 + 少糖
配料：加珍珠 + 加椰果
SKU：招牌奶茶_大杯_少糖_加珍珠_加椰果

价格计算：
最终价格 = 基础价格 + 规格价格差 + 配料价格之和
         = 12元 + 3元（大杯）+ 2元（珍珠）+ 2元（椰果）
         = 19元
```

### 4.2 SKU是否需要预生成？

```
两种方案对比：

方案1：预生成所有SKU
优点：查询快，库存管理简单
缺点：SKU数量爆炸（规格数×配料数的组合）
适用：规格简单，组合少的场景

方案2：动态计算SKU
优点：存储少，灵活
缺点：价格计算复杂，库存管理复杂
适用：规格复杂，组合多的场景

我们的选择：
- 核心SKU预生成（高频组合）
- 长尾SKU动态计算
- 库存按商品级别管理，不按SKU
```

### 4.3 SKU表设计（简化版）

```sql
-- 我们实际上没有独立的SKU表
-- 而是在下单时动态计算

-- 订单商品表中保存选中的规格和配料
CREATE TABLE order_item (
    id BIGINT PRIMARY KEY,
    order_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    product_name VARCHAR(100),
    product_image VARCHAR(255),

    -- 规格快照
    specs JSON,                    -- [{"name":"杯型","value":"大杯","price":3}]

    -- 配料快照
    additions JSON,                -- [{"name":"珍珠","price":2},{"name":"椰果","price":2}]

    -- 价格
    unit_price DECIMAL(10,2),      -- 单价（已计算规格和配料）
    quantity INT,
    total_price DECIMAL(10,2),

    INDEX idx_order (order_id)
);
```

---

## 五、属性与标签设计

### 5.1 属性分类

```
商品属性分类：

1. 销售属性（影响价格/库存）
   - 规格：大/中/小
   - 配料：加珍珠、加椰果
   - 已通过规格表和配料表管理

2. 展示属性（不影响价格）
   - 口味：微辣/中辣/特辣
   - 忌口：不要葱/不要香菜
   - 备注：少盐/多放醋

3. 搜索属性
   - 分类：饮品/主食/小吃
   - 标签：新品/招牌/热销
   - 菜系：川菜/粤菜/湘菜

4. 运营属性
   - 推荐权重
   - 活动标记
   - 品质标签
```

### 5.2 属性存储

```java
// 使用JSON存储扩展属性
@Data
public class ProductAttributes {
    // 展示属性
    private String spicyLevel;      // 辣度
    private String taste;           // 口味
    private List<String> allergens; // 过敏原
    private Integer calories;       // 卡路里

    // 搜索属性
    private List<String> tags;      // 标签
    private String cuisine;         // 菜系

    // 运营属性
    private Integer recommendScore; // 推荐分数
    private Boolean isNew;          // 是否新品
    private Boolean isSignature;    // 是否招牌
}

// 存储为JSON
{
    "spicyLevel": "medium",
    "taste": "香辣",
    "allergens": ["花生", "牛奶"],
    "calories": 450,
    "tags": ["新品", "招牌", "必点"],
    "cuisine": "川菜",
    "recommendScore": 95,
    "isNew": true,
    "isSignature": true
}
```

### 5.3 标签系统

```sql
-- 标签定义表
CREATE TABLE product_tag (
    id BIGINT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,          -- 标签名称
    type VARCHAR(20) NOT NULL,          -- 标签类型：SYSTEM/MERCHANT/ACTIVITY
    icon VARCHAR(255),                  -- 标签图标
    color VARCHAR(20),                  -- 标签颜色
    priority INT DEFAULT 0,             -- 优先级（展示顺序）
    status TINYINT DEFAULT 1
);

-- 商品标签关联表
CREATE TABLE product_tag_relation (
    id BIGINT PRIMARY KEY,
    product_id BIGINT NOT NULL,
    tag_id BIGINT NOT NULL,
    create_time DATETIME,
    UNIQUE KEY uk_product_tag (product_id, tag_id)
);
```

**标签类型：**
```
1. 系统标签（自动打标）
   - 热销：销量排名前10%
   - 新品：上架7天内
   - 好评：评分4.5以上

2. 商家标签（商家设置）
   - 招牌
   - 必点
   - 店长推荐

3. 活动标签（运营设置）
   - 限时特价
   - 满减
   - 新客专享
```

---

## 六、分类设计

### 6.1 分类模型

```sql
CREATE TABLE product_category (
    id BIGINT PRIMARY KEY,
    merchant_id BIGINT NOT NULL,        -- 商家ID（分类按商家隔离）
    parent_id BIGINT DEFAULT 0,         -- 父分类ID（支持多级）
    name VARCHAR(50) NOT NULL,          -- 分类名称
    icon VARCHAR(255),                  -- 分类图标
    sort_order INT DEFAULT 0,           -- 排序
    status TINYINT DEFAULT 1,           -- 状态
    time_range VARCHAR(50),             -- 适用时间段（如：06:00-10:00）
    INDEX idx_merchant (merchant_id),
    INDEX idx_parent (parent_id)
);
```

### 6.2 分类特点

```
外卖分类的特点：

1. 商家级别
   - 每个商家有自己的分类
   - 不是全局统一分类
   - 商家可以自定义分类名称

2. 时间属性
   - 早餐分类（6:00-10:00）
   - 午餐分类（10:00-14:00）
   - 下午茶分类（14:00-17:00）
   - 晚餐分类（17:00-21:00）

3. 展示优化
   - "热销"分类自动聚合销量TOP商品
   - "优惠"分类自动聚合参与活动的商品
```

---

## 七、实际案例

### 7.1 奶茶店商品建模

```json
{
    "product": {
        "id": 10001,
        "name": "招牌珍珠奶茶",
        "basePrice": 12.00,
        "categoryId": 1,
        "labels": ["招牌", "热销"]
    },
    "specGroups": [
        {
            "name": "杯型",
            "required": true,
            "specs": [
                {"name": "大杯", "priceDiff": 3.00, "isDefault": false},
                {"name": "中杯", "priceDiff": 0.00, "isDefault": true},
                {"name": "小杯", "priceDiff": -2.00, "isDefault": false}
            ]
        },
        {
            "name": "温度",
            "required": true,
            "specs": [
                {"name": "热", "priceDiff": 0.00},
                {"name": "冰", "priceDiff": 0.00, "isDefault": true},
                {"name": "常温", "priceDiff": 0.00}
            ]
        },
        {
            "name": "甜度",
            "required": true,
            "specs": [
                {"name": "全糖", "priceDiff": 0.00, "isDefault": true},
                {"name": "七分糖", "priceDiff": 0.00},
                {"name": "半糖", "priceDiff": 0.00},
                {"name": "无糖", "priceDiff": 0.00}
            ]
        }
    ],
    "additionGroups": [
        {
            "name": "加料",
            "required": false,
            "maxSelect": 3,
            "additions": [
                {"name": "珍珠", "price": 2.00},
                {"name": "椰果", "price": 2.00},
                {"name": "红豆", "price": 2.00},
                {"name": "仙草", "price": 3.00}
            ]
        }
    ]
}
```

### 7.2 快餐店商品建模

```json
{
    "product": {
        "id": 20001,
        "name": "黄焖鸡米饭",
        "basePrice": 25.00,
        "categoryId": 2,
        "labels": ["招牌"]
    },
    "specGroups": [
        {
            "name": "份量",
            "required": true,
            "specs": [
                {"name": "大份", "priceDiff": 5.00},
                {"name": "中份", "priceDiff": 0.00, "isDefault": true},
                {"name": "小份", "priceDiff": -3.00}
            ]
        },
        {
            "name": "辣度",
            "required": true,
            "specs": [
                {"name": "特辣", "priceDiff": 0.00},
                {"name": "中辣", "priceDiff": 0.00, "isDefault": true},
                {"name": "微辣", "priceDiff": 0.00},
                {"name": "不辣", "priceDiff": 0.00}
            ]
        }
    ],
    "additionGroups": [
        {
            "name": "加菜",
            "required": false,
            "maxSelect": 5,
            "additions": [
                {"name": "加鸡腿", "price": 6.00},
                {"name": "加鸡蛋", "price": 2.00},
                {"name": "加青菜", "price": 3.00},
                {"name": "加土豆", "price": 2.00}
            ]
        }
    ]
}
```

---

## 八、最佳实践

### 8.1 建模原则

```
1. 简单优先
   - 外卖商品不需要复杂的SPU/SKU体系
   - 规格+配料能覆盖90%场景
   - 复杂需求通过扩展字段解决

2. 业务导向
   - 模型设计服务于业务场景
   - 下单流程决定模型结构
   - 展示需求决定字段设计

3. 可扩展
   - 使用JSON存储扩展属性
   - 预留扩展字段
   - 新业务尽量不改表结构

4. 性能考虑
   - 热数据和冷数据分离
   - 商品快照存储在订单中
   - 规格配料内嵌查询
```

### 8.2 常见陷阱

```
1. 过度设计
   - 照搬电商的SPU/SKU体系
   - 设计复杂的属性继承关系
   - 结果：开发复杂，查询慢

2. 忽视时效性
   - 没有考虑营业时间
   - 没有考虑限时商品
   - 结果：商品展示逻辑复杂

3. 价格计算不清晰
   - 规格、配料、活动价格混在一起
   - 结果：价格计算错误，用户投诉
```
