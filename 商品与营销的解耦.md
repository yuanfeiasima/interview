# 商品与营销的解耦

## 核心要点（面试快速回答）

**Q: 如何设计才能让商品系统不被营销逻辑污染？**
核心原则是"商品只管商品，价格计算交给营销"。商品系统只存储原价，不存储活动价。价格计算统一由价格中心负责，接收商品ID、用户ID、活动信息，返回最终价格。商品系统对营销活动无感知。

**Q: 商品价格的计算逻辑在哪里？**
在独立的价格计算服务（价格中心）。计算流程：基础价格（商品系统）→ 规格配料价格（商品系统）→ 会员价（用户系统）→ 活动价（营销系统）→ 优惠券抵扣（营销系统）。每一步独立计算，最后聚合。

**Q: 满减、折扣这些怎么和商品关联？**
通过"活动-商品"关联表，而不是在商品表中加字段。活动有自己的生命周期，商品不感知活动状态。展示层查询时，先查商品，再查该商品参与的活动，最后聚合展示。

**Q: 这样设计的好处是什么？**
三个好处：1）商品系统稳定，不因营销变化而频繁改动；2）营销逻辑集中管理，便于复用和调整；3）价格计算可追溯，出问题容易排查。

---

## 一、问题背景

### 1.1 营销对商品的影响

```
外卖场景的营销活动类型：

1. 商品级活动
   - 单品折扣：某商品打8折
   - 单品特价：某商品特价9.9元
   - 第二份半价：第二份同商品半价

2. 订单级活动
   - 满减：满30减5
   - 满赠：满50送饮料
   - 满折：满100打9折

3. 用户级活动
   - 新人专享价
   - 会员专属价
   - 定向优惠券

4. 时间级活动
   - 限时折扣
   - 早餐特惠
   - 闪购秒杀
```

### 1.2 不解耦的痛点

```
如果营销逻辑混入商品系统：

问题1：字段爆炸
- 商品表要加：折扣价、秒杀价、会员价、新人价...
- 每新增一种活动就要加字段
- 表结构越来越臃肿

问题2：逻辑混乱
- 价格计算逻辑散落在各处
- 活动优先级判断复杂
- 价格展示和实际支付不一致

问题3：维护困难
- 改营销逻辑要动商品代码
- 活动上下线影响商品服务
- 出问题难以定位

问题4：扩展受限
- 新活动类型难以支持
- 活动组合规则无法灵活配置
```

---

## 二、解耦架构设计

### 2.1 整体架构

```
解耦后的架构：

┌─────────────────────────────────────────────────────────┐
│                      展示层/交易层                        │
└───────────────────────────┬─────────────────────────────┘
                            │
         ┌──────────────────┼──────────────────┐
         │                  │                  │
         ▼                  ▼                  ▼
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  商品服务    │    │  价格中心    │    │  营销服务    │
│             │    │             │    │             │
│ - 商品信息  │    │ - 价格计算   │    │ - 活动管理  │
│ - 规格配料  │    │ - 价格聚合   │    │ - 优惠券    │
│ - 库存      │    │ - 价格展示   │    │ - 满减规则  │
└─────────────┘    └─────────────┘    └─────────────┘
       │                  │                  │
       └──────────────────┼──────────────────┘
                          │
                          ▼
                 ┌─────────────┐
                 │   数据层     │
                 │  (各自独立)  │
                 └─────────────┘
```

### 2.2 职责划分

| 系统 | 职责 | 不负责 |
|-----|-----|-------|
| **商品服务** | 商品基础信息、原价、规格配料、库存 | 活动价、优惠计算 |
| **营销服务** | 活动配置、规则管理、优惠券发放 | 商品信息、价格展示 |
| **价格中心** | 价格计算、价格聚合、价格展示 | 活动规则、商品管理 |

### 2.3 数据边界

```
商品服务数据：
- product 表：商品基础信息
- product_spec 表：规格
- product_addition 表：配料
- product_stock 表：库存
【不存储任何活动相关字段】

营销服务数据：
- activity 表：活动定义
- activity_product 表：活动商品关联
- activity_rule 表：活动规则
- coupon 表：优惠券
【不存储商品详情】

价格中心数据：
- 无持久化数据
- 实时计算，结果可缓存
```

---

## 三、活动与商品的关联

### 3.1 关联模型

**为什么用关联表而不是在商品表加字段**：
1. 一个商品可能参与多个活动，加字段会导致字段爆炸
2. 活动有自己的生命周期（开始、结束），商品表不应该感知
3. 解耦后，删除活动不影响商品，修改商品不影响活动

**关联表设计要点**：
- activity_id + product_id 唯一索引，防止重复关联
- activity_price/discount_rate 存储活动价格信息
- limit_count 支持限购功能

```sql
-- 活动表（营销服务）
CREATE TABLE activity (
    id BIGINT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    type VARCHAR(20) NOT NULL,          -- DISCOUNT/SPECIAL_PRICE/FULL_REDUCE
    status TINYINT DEFAULT 0,           -- 0草稿 1生效 2结束
    start_time DATETIME,
    end_time DATETIME,
    rules JSON,                         -- 活动规则
    priority INT DEFAULT 0,             -- 优先级
    create_time DATETIME
);

-- 活动商品关联表
CREATE TABLE activity_product (
    id BIGINT PRIMARY KEY,
    activity_id BIGINT NOT NULL,
    merchant_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    activity_price DECIMAL(10,2),       -- 活动价格（特价类活动）
    discount_rate DECIMAL(3,2),         -- 折扣率（折扣类活动）
    limit_count INT,                    -- 限购数量
    create_time DATETIME,
    UNIQUE KEY uk_activity_product (activity_id, product_id),
    INDEX idx_product (product_id),
    INDEX idx_merchant (merchant_id)
);
```

### 3.2 活动类型设计

```java
// 活动类型枚举
public enum ActivityType {
    DISCOUNT("折扣", "商品打折"),
    SPECIAL_PRICE("特价", "商品固定价格"),
    SECOND_HALF("第二份半价", "第二份商品半价"),
    FULL_REDUCE("满减", "满XX减XX"),
    FULL_GIFT("满赠", "满XX送商品"),
    NEW_USER("新人价", "新用户专享"),
    MEMBER("会员价", "会员专属");

    private String name;
    private String desc;
}

// 活动规则定义
@Data
public class ActivityRule {
    private ActivityType type;

    // 折扣类
    private BigDecimal discountRate;     // 折扣率，如0.8表示8折

    // 特价类
    private BigDecimal specialPrice;     // 特价

    // 满减类
    private List<FullReduceRule> fullReduceRules;  // 满减阶梯

    // 限制条件
    private Integer limitPerUser;        // 每人限购
    private Integer totalLimit;          // 总限量
    private List<Long> applicableProducts;  // 适用商品
}

@Data
public class FullReduceRule {
    private BigDecimal threshold;        // 满多少
    private BigDecimal reduce;           // 减多少
}
```

### 3.3 查询活动商品

```java
// 商品服务：只返回商品基础信息
public Product getProduct(Long productId) {
    return productDao.selectById(productId);
}

// 营销服务：查询商品参与的活动
public List<ProductActivity> getProductActivities(Long productId) {
    // 查询该商品参与的所有生效中的活动
    return activityProductDao.selectActiveByProductId(productId, new Date());
}

// 聚合层：组装商品+活动信息
public ProductVO getProductWithActivity(Long productId, Long userId) {
    // 1. 获取商品基础信息
    Product product = productService.getProduct(productId);

    // 2. 获取商品参与的活动
    List<ProductActivity> activities = marketingService
        .getProductActivities(productId);

    // 3. 计算最优价格
    PriceResult priceResult = priceCenter.calculate(
        product.getId(), product.getPrice(), userId, activities);

    // 4. 组装VO
    ProductVO vo = new ProductVO();
    vo.setProduct(product);
    vo.setOriginalPrice(product.getPrice());
    vo.setFinalPrice(priceResult.getFinalPrice());
    vo.setActivities(activities);
    vo.setPriceTag(priceResult.getPriceTag());  // 如"限时特价"、"会员价"

    return vo;
}
```

---

## 四、价格中心设计

### 4.1 价格计算流程

**流水线设计的好处**：
1. 每一步职责单一，便于理解和维护
2. 步骤可以独立修改，不影响其他步骤
3. 新增优惠类型只需要加一步，不用改现有代码
4. 计算过程透明，可以输出详细的价格明细

**计算顺序的原因**：
- 先商品级活动：因为会影响单品价格
- 再用户级优惠：会员价等基于单品价格计算
- 最后订单级优惠：满减等基于订单总价计算

```
价格计算流水线：

输入：商品ID、用户ID、购买数量、已选优惠券

     ┌─────────────────────────────────────────────────┐
     │              价格计算流水线                       │
     ├─────────────────────────────────────────────────┤
Step1│ 获取商品基础价格                                 │
     │ basePrice = product.price + specs + additions   │
     ├─────────────────────────────────────────────────┤
Step2│ 应用商品级活动（取最优）                          │
     │ activityPrice = applyProductActivity(basePrice) │
     ├─────────────────────────────────────────────────┤
Step3│ 应用用户级优惠（会员价、新人价）                   │
     │ userPrice = applyUserDiscount(activityPrice)    │
     ├─────────────────────────────────────────────────┤
Step4│ 计算订单级优惠（满减、满赠）                      │
     │ orderDiscount = calculateOrderDiscount(items)   │
     ├─────────────────────────────────────────────────┤
Step5│ 应用优惠券                                       │
     │ couponDiscount = applyCoupon(orderTotal)        │
     ├─────────────────────────────────────────────────┤
     │ finalPrice = orderTotal - orderDiscount         │
     │              - couponDiscount                   │
     └─────────────────────────────────────────────────┘

输出：最终价格、价格明细、应用的优惠
```

### 4.2 价格计算服务

```java
@Service
public class PriceCalculateService {

    public PriceResult calculate(PriceCalculateRequest request) {
        PriceResult result = new PriceResult();
        List<PriceDetail> details = new ArrayList<>();

        // Step1: 商品基础价格
        BigDecimal basePrice = calculateBasePrice(request);
        details.add(new PriceDetail("商品原价", basePrice));

        // Step2: 商品级活动
        ActivityPriceResult activityResult = applyProductActivity(
            request.getProductId(), basePrice);
        if (activityResult.hasDiscount()) {
            details.add(new PriceDetail(
                activityResult.getActivityName(),
                activityResult.getDiscount().negate()));
        }
        BigDecimal afterActivity = activityResult.getPrice();

        // Step3: 用户级优惠
        UserPriceResult userResult = applyUserDiscount(
            request.getUserId(), afterActivity);
        if (userResult.hasDiscount()) {
            details.add(new PriceDetail(
                userResult.getDiscountType(),
                userResult.getDiscount().negate()));
        }
        BigDecimal afterUser = userResult.getPrice();

        // Step4: 数量计算
        BigDecimal itemTotal = afterUser.multiply(
            new BigDecimal(request.getQuantity()));

        // 汇总结果
        result.setFinalPrice(itemTotal);
        result.setDetails(details);
        result.setPriceTag(determinePriceTag(activityResult, userResult));

        return result;
    }

    private BigDecimal calculateBasePrice(PriceCalculateRequest request) {
        // 基础价格 + 规格差价 + 配料价格
        BigDecimal base = request.getBasePrice();

        for (SelectedSpec spec : request.getSpecs()) {
            base = base.add(spec.getPriceDiff());
        }

        for (SelectedAddition addition : request.getAdditions()) {
            base = base.add(addition.getPrice());
        }

        return base;
    }
}
```

### 4.3 活动优先级处理

**为什么需要优先级处理**：一个商品可能同时参与多个活动（比如既有折扣又有特价），这时要选择对用户最优惠的。计算每个活动的优惠金额，取最大的。如果优惠金额相同，按活动配置的优先级决定。

**选择最优活动的逻辑**：
1. 计算每个活动能优惠多少钱
2. 按优惠金额降序排列
3. 取优惠最多的活动

```java
// 多个活动时的优先级处理
public class ActivityPriorityHandler {

    // 商品级活动优先级规则
    public ProductActivity selectBestActivity(
            List<ProductActivity> activities, BigDecimal basePrice) {

        if (activities.isEmpty()) {
            return null;
        }

        // 计算每个活动的优惠金额
        List<ActivityWithDiscount> withDiscounts = activities.stream()
            .map(a -> {
                BigDecimal discount = calculateDiscount(a, basePrice);
                return new ActivityWithDiscount(a, discount);
            })
            .collect(Collectors.toList());

        // 按优惠金额排序，取最优
        // 如果优惠金额相同，按活动优先级排序
        return withDiscounts.stream()
            .sorted((a, b) -> {
                int cmp = b.getDiscount().compareTo(a.getDiscount());
                if (cmp != 0) return cmp;
                return b.getActivity().getPriority() - a.getActivity().getPriority();
            })
            .findFirst()
            .map(ActivityWithDiscount::getActivity)
            .orElse(null);
    }

    private BigDecimal calculateDiscount(ProductActivity activity, BigDecimal basePrice) {
        switch (activity.getType()) {
            case DISCOUNT:
                // 折扣：原价 × (1-折扣率)
                return basePrice.multiply(
                    BigDecimal.ONE.subtract(activity.getDiscountRate()));

            case SPECIAL_PRICE:
                // 特价：原价 - 特价
                return basePrice.subtract(activity.getActivityPrice());

            default:
                return BigDecimal.ZERO;
        }
    }
}
```

---

## 五、订单级优惠计算

### 5.1 满减计算

```java
public class FullReduceCalculator {

    public FullReduceResult calculate(List<OrderItem> items,
            List<FullReduceActivity> activities) {

        // 计算可参与满减的商品总价
        BigDecimal eligibleTotal = items.stream()
            .filter(item -> isEligibleForFullReduce(item))
            .map(OrderItem::getTotalPrice)
            .reduce(BigDecimal.ZERO, BigDecimal::add);

        // 找出最优的满减活动
        FullReduceActivity bestActivity = null;
        BigDecimal bestReduce = BigDecimal.ZERO;

        for (FullReduceActivity activity : activities) {
            BigDecimal reduce = calculateReduce(eligibleTotal, activity);
            if (reduce.compareTo(bestReduce) > 0) {
                bestReduce = reduce;
                bestActivity = activity;
            }
        }

        return new FullReduceResult(bestActivity, bestReduce);
    }

    private BigDecimal calculateReduce(BigDecimal total,
            FullReduceActivity activity) {
        // 从高到低遍历满减阶梯
        List<FullReduceRule> rules = activity.getRules();
        rules.sort((a, b) -> b.getThreshold().compareTo(a.getThreshold()));

        for (FullReduceRule rule : rules) {
            if (total.compareTo(rule.getThreshold()) >= 0) {
                return rule.getReduce();
            }
        }

        return BigDecimal.ZERO;
    }
}
```

### 5.2 优惠券计算

```java
public class CouponCalculator {

    public CouponResult calculate(BigDecimal orderTotal, Coupon coupon) {
        // 检查优惠券是否可用
        if (!isUsable(coupon, orderTotal)) {
            return CouponResult.notUsable(coupon, "不满足使用条件");
        }

        BigDecimal discount;
        switch (coupon.getType()) {
            case FIXED:
                // 固定金额券
                discount = coupon.getAmount();
                break;

            case PERCENT:
                // 折扣券
                discount = orderTotal.multiply(
                    BigDecimal.ONE.subtract(coupon.getDiscount()));
                // 封顶
                if (coupon.getMaxDiscount() != null) {
                    discount = discount.min(coupon.getMaxDiscount());
                }
                break;

            case FULL_REDUCE:
                // 满减券
                if (orderTotal.compareTo(coupon.getThreshold()) >= 0) {
                    discount = coupon.getAmount();
                } else {
                    return CouponResult.notUsable(coupon, "未满" + coupon.getThreshold());
                }
                break;

            default:
                discount = BigDecimal.ZERO;
        }

        return CouponResult.success(coupon, discount);
    }
}
```

---

## 六、价格展示

### 6.1 商品列表价格展示

```java
public class ProductListPriceService {

    // 批量获取商品价格（用于列表页）
    public Map<Long, ProductPriceVO> batchGetPrices(
            List<Long> productIds, Long userId) {

        Map<Long, ProductPriceVO> result = new HashMap<>();

        // 1. 批量获取商品原价
        Map<Long, BigDecimal> originalPrices = productService
            .batchGetPrices(productIds);

        // 2. 批量获取商品活动
        Map<Long, List<ProductActivity>> activityMap = marketingService
            .batchGetProductActivities(productIds);

        // 3. 获取用户信息（判断是否新人/会员）
        User user = userService.getById(userId);

        // 4. 计算每个商品的展示价格
        for (Long productId : productIds) {
            BigDecimal originalPrice = originalPrices.get(productId);
            List<ProductActivity> activities = activityMap
                .getOrDefault(productId, Collections.emptyList());

            ProductPriceVO priceVO = calculateDisplayPrice(
                originalPrice, activities, user);

            result.put(productId, priceVO);
        }

        return result;
    }

    private ProductPriceVO calculateDisplayPrice(BigDecimal originalPrice,
            List<ProductActivity> activities, User user) {

        ProductPriceVO vo = new ProductPriceVO();
        vo.setOriginalPrice(originalPrice);

        // 找最优活动价
        BigDecimal bestPrice = originalPrice;
        String priceTag = null;

        for (ProductActivity activity : activities) {
            BigDecimal activityPrice = calculateActivityPrice(
                originalPrice, activity);
            if (activityPrice.compareTo(bestPrice) < 0) {
                bestPrice = activityPrice;
                priceTag = activity.getName();
            }
        }

        // 检查会员价
        if (user.isVip()) {
            BigDecimal vipPrice = originalPrice.multiply(new BigDecimal("0.95"));
            if (vipPrice.compareTo(bestPrice) < 0) {
                bestPrice = vipPrice;
                priceTag = "会员价";
            }
        }

        vo.setDisplayPrice(bestPrice);
        vo.setPriceTag(priceTag);
        vo.setHasDiscount(bestPrice.compareTo(originalPrice) < 0);

        return vo;
    }
}
```

### 6.2 价格标签展示

```java
// 价格标签类型
public enum PriceTag {
    SPECIAL_PRICE("特价", "#FF4444"),
    DISCOUNT("折扣", "#FF6600"),
    MEMBER_PRICE("会员价", "#9933FF"),
    NEW_USER("新人价", "#00CC66"),
    FLASH_SALE("秒杀", "#FF0000"),
    SECOND_HALF("第二份半价", "#FF9900");

    private String text;
    private String color;
}

// 前端展示
{
    "productId": 10001,
    "name": "招牌奶茶",
    "originalPrice": 15.00,
    "displayPrice": 9.90,
    "priceTag": {
        "text": "特价",
        "color": "#FF4444"
    },
    "discount": "6.6折"
}
```

---

## 七、下单价格校验

### 7.1 为什么需要校验？

**价格校验的必要性**：
1. **缓存延迟**：用户看到的价格可能是缓存的，活动可能已结束
2. **并发问题**：限量活动可能被抢完，用户还能看到活动价
3. **恶意请求**：用户可能篡改前端提交的价格参数

**核心原则**：永远不要相信前端提交的价格，服务端必须重新计算并校验。

```
价格校验的必要性：

风险1：缓存延迟
- 用户看到的是缓存价格
- 下单时活动可能已结束
- 需要校验实时价格

风险2：并发问题
- 限量活动可能被抢完
- 需要校验活动资格

风险3：恶意请求
- 用户可能篡改价格参数
- 需要服务端重新计算
```

### 7.2 校验流程

```java
public class OrderPriceValidator {

    public ValidationResult validate(OrderSubmitRequest request) {
        ValidationResult result = new ValidationResult();

        // 1. 重新计算价格
        PriceResult calculated = priceCalculateService.calculate(
            request.toCalculateRequest());

        // 2. 对比提交的价格和计算的价格
        BigDecimal submittedPrice = request.getTotalPrice();
        BigDecimal calculatedPrice = calculated.getFinalPrice();

        if (submittedPrice.compareTo(calculatedPrice) != 0) {
            // 价格不一致
            result.setValid(false);
            result.setPriceChanged(true);
            result.setNewPrice(calculatedPrice);
            result.setMessage("商品价格有变化，请确认后重新下单");
            return result;
        }

        // 3. 校验活动资格
        for (AppliedActivity activity : request.getActivities()) {
            ActivityValidation activityResult = validateActivity(
                activity, request.getUserId());
            if (!activityResult.isValid()) {
                result.setValid(false);
                result.setMessage(activityResult.getMessage());
                return result;
            }
        }

        // 4. 校验优惠券
        if (request.getCouponId() != null) {
            CouponValidation couponResult = validateCoupon(
                request.getCouponId(), request.getUserId(), calculatedPrice);
            if (!couponResult.isValid()) {
                result.setValid(false);
                result.setMessage(couponResult.getMessage());
                return result;
            }
        }

        result.setValid(true);
        return result;
    }
}
```

---

## 八、最佳实践

### 8.1 解耦原则

```
1. 单一职责
   - 商品服务只管商品
   - 营销服务只管活动
   - 价格中心只管计算

2. 数据隔离
   - 商品表不存储活动信息
   - 通过关联表建立联系
   - 删除活动不影响商品

3. 接口标准化
   - 定义清晰的价格计算接口
   - 输入输出明确
   - 便于扩展新活动类型

4. 可追溯
   - 价格明细要记录
   - 每一步优惠都有来源
   - 方便排查问题
```

### 8.2 注意事项

```
1. 价格一致性
   - 展示价格和支付价格要一致
   - 有变化要明确提示用户
   - 不能静默改价

2. 活动优先级
   - 多活动时优先级要清晰
   - 通常取用户最优惠的
   - 互斥活动要标注

3. 性能优化
   - 价格计算要缓存
   - 批量接口减少调用
   - 热点活动要预计算

4. 异常处理
   - 活动查询失败不影响下单
   - 降级返回原价
   - 记录日志便于排查
```
